---
article: false
date: 2024-10-30
index: true
order: 10
headerDepth: 0
---

# Privacy Enhancing Crypto

How signature is used in blockchain

- 核心思想：公钥 = 身份
- 如果你看到签名sig，使得Verify(pk, msg, sig) = true，可以理解为公钥pk在说，“[消息]”
- UTXO model in Bitcoin, Account model in Ethereum 都使用了 signature

How to make a new identity

- Create a new, random key-pair (sk, pk)
- pk (or the address Hash(pk)) is the public "name" you can use
- You control the identity, because only you know sk
- 无需许可「Permissionless」：任何人可以在任何时间创建一个新的身份。这个过程不需要中央机构的批准或参与。
- Make as many as you want! No central coordination!
- pk "looks random" and not directly connect to real-world identity?!
- 发送者可以为接收者“创建”一个公钥，以实现接收者的匿名性，例如在Monero中（Monero使用UTXO模型). 这种方法可以隐藏接收者的真实身份。

## Pseudonymous

「假名」

![1730296253162.png](https://pic.hanjiaming.com.cn/2024/10/30/5efdf7fee9ea3.png)

- 在区块链系统中，交易是公开的，因此需要额外的技术手段来保护用户的隐私。
- 比特币交易是公开的，但参与者的身份是隐藏的，只有他们的比特币地址是可见的。
- 这种假名性意味着虽然地址不直接显示用户的真实身份，但通过分析交易记录，仍然可以推断出用户的行为和身份。
- 公钥地址是由公钥生成的字符串，用于接收比特币。它类似于银行账号，可以公开分享。
- 一旦比特币地址与某个人的真实身份关联起来，所有通过该地址进行的交易记录都可以追溯到这个人，从而揭示其财务活动和行为。

## Anonymity

or precisely, unlinkability「或者准确地说，不可链接性」

对手银行无法将一笔取款交易与一笔存款交易关联起来。这意味着在电子现金系统中，用户可以从银行取款，然后在不透露身份的情况下将其花费在商家处，而银行无法追踪这些交易。

1. Alice从银行账户中取出100单位的电子现金。
2. 电子现金系统通过加密技术生成一个匿名的电子现金凭证，Alice可以用这个凭证进行支付。
3. Alice在Bob处消费100单位的电子现金，Bob接收到电子现金凭证。
4. Bob将电子现金凭证存入他的银行账户，银行验证凭证的合法性，但无法追踪到Alice。

<img src="https://pic.hanjiaming.com.cn/2024/10/30/7c81a8a211a5c.png" alt="1730296684084.png" style="zoom: 50%;" />

### Fungibility

「可替代性」

- 个体单位可以互相替代：这意味着一个单位的资产可以用另一个相同单位的资产替代，而不会影响其价值
- 比特币可能与你相关，或者被污染「tainted」。
  - 比特币的交易记录是公开的，因此每个比特币的历史可以被追踪到。
  - 如果某个比特币曾经用于非法活动，它可能会被认为是“污染的”。
- 由于比特币的交易记录是公开的，但不一定每个人都会去查看，因此你可能在持有比特币时并不知道它的历史，直到你尝试交换或出售它时才发现。

### Transparency of Blockchain

「透明性」

- 区块链的透明性可以提高系统的可信度和安全性。
- 透明性对于敏感信息来说是不理想的「desirable」。
  - 金融交易中的敏感信息如果被公开，可能会导致隐私泄露和安全风险。
  - 例如，两家银行之间的交易细节不应被其他银行知道。

## 3 Types of Privacy

3 Types of Privacy, 3 Cryptocurrencies with Privacy

### Zcash (#20, S&P '14)

- **Use ZK-SNARK**：Zcash 使用 ZK-SNARK 技术来实现交易的零知识证明，从而确保交易的隐私性。
- Zcash 的零知识证明技术可以扩展到零知识智能合约，使得智能合约的执行过程也能保持隐私。
- K-SNARK 的证明时间大约为 30 秒。
- ZK-SNARK 目前需要一个可信的初始化设置，但未来可以通过技术升级来消除这一需求。

### Monero (#13)

- 门罗币通过可链接环签名技术实现发送方的匿名性。
- 通过 Diffie-Hellman 密钥交换实现接收方的匿名性。
- 使用离散对数承诺方案来保证交易内容的隐私。隐私保护技术在实际应用中非常实用。
- 匿名性在扩展性方面存在问题，隐藏发送方的计算复杂度为 O(n)。

### Dash (#15)

- 达世币基于 CoinJoin 技术，通过将多个交易的输入和输出混合在一起实现匿名性。
- 达世币使用同态加密「homomorphic」技术将多个交易的输入和输出混合在一起。
- 达世币的匿名性有限，可能无法完全隐藏交易各方的身份。

## Privacy Concerns in Signatures

What can we do “with” signatures?

- 一个人可以在一条消息上签名。
- 任何人都可以验证一个签名（基于消息和身份）。
- (Accountable「可追责的」) Signer (Identity) Privacy

## Blind Signature

### A Simple E-Cash System

你希望在使用电子现金时保持匿名，不让别人知道你具体的消费记录。银行的要求是：他们不希望你进行双重花费。

- 你存入100美元，银行会给你100个1美元的电子硬币。
- 这个过程类似于在银行存款，但你得到的是电子形式的货币。
- 你以签名的形式提取一个单位（1美元）的硬币。这里的签名指的是数字签名，它代表了你对这1美元的所有权。
- 以每个硬币都有一个序列号。这个序列号用于追踪每个电子硬币的使用情况。
- 当你“花费”一个签名时，商家和后来银行会知道这个序列号。
  这个过程确保了每次交易的合法性和可追溯性。但也泄露了你发消费记录。
- 当商家或银行看到相同的序列号时，说明有人进行了双重花费。
- 但由于盲签名技术，提取和消费之间没有关联。
  - **提取阶段**：用户从银行提取电子现金时，用户生成一个随机数并将其与电子现金的标识信息结合，形成一个遮蔽后的消息。银行对这个遮蔽后的消息进行签名，而不知原始消息内容。
  - 用户在商家处使用电子现金时，用户解除遮蔽，向商家展示电子现金的原始标识信息和银行的签名。商家可以验证银行的签名但无法知道用户的身份或提取过程。

这是传统加密电子现金的起点（ZeroCash使用了一些类似的概念）。ZeroCash是一种基于零知识证明的电子现金系统，进一步增强了隐私保护。

### Functionalities

- 你，作为签名请求者，希望获得一个签名。
- 但是你不希望签名者知道被签名的内容。
- KeyGen()是密钥生成函数，它生成一对公钥和私钥，用于加密和签名。
- 签名变成一个协议或一组算法。签名过程包括多个步骤，确保在保持隐私的情况下完成签名。
- Blind(pk, m) -> (m', r)。
  盲化过程使用公钥(pk)和消息(m)生成盲化消息(m')和盲化因子(r)。
- Blind-Sign(sk, m') -> S'
  盲签名过程使用私钥(sk)对盲化消息(m')进行签名，生成盲签名(S')。
- Unblind(pk, S', r) -> S
  去盲化过程使用公钥(pk)、盲签名(S')和盲化因子(r)恢复原始签名(S)。
- 验证函数Verify()使用公钥(pk)和消息(m)验证签名(S)的真实性。

### Generic Scheme

A “Generic” Blind Signature Scheme

Blind(pk, m) -> (m', r)

- 在盲签名过程中，首先需要对消息 m 进行盲化处理，这个过程称为 Blind。
- 这里的 pk 是公钥，m 是需要签名的消息。
- 盲化过程生成了一个新的消息 m'，它是 m 的承诺，同时生成一个随机值 r 作为打开值。
- 这个过程确保了签名者看不到原始消息 m。

Blind-Sign(sk, m') -> S'

- 在这个步骤中，签名者使用其私钥 sk 对盲化后的消息 m' 进行签名，生成签名 S'。
- 由于 m' 是盲化后的消息，签名者无法得知原始消息 m 的内容。
- 这个步骤确保了消息的隐私性，同时生成了一个有效的签名。

Unblind(pk, S', r) -> S

- 在这个步骤中，请求者使用打开值 r 和公钥 pk 对签名 S' 进行去盲化，恢复出对原始消息 m 的签名 S。
- 这个过程验证了签名的有效性。

然而，这种方法存在问题，因为签名者可以看到 S' 中的 m'，从而可能将其与原始消息 m 联系起来。

这种联系的原因可能包括以下几点：













