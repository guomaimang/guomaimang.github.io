import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as l,e as a}from"./app-06102085.js";const r={},n=a('<h1 id="jwt-续签方案详解" tabindex="-1"><a class="header-anchor" href="#jwt-续签方案详解" aria-hidden="true">#</a> JWT 续签方案详解</h1><p>在前后端分离架构下，JWT（JSON Web Token）认证方案广泛应用。</p><p>然而，JWT的无状态性使得其续签功能的实现变得棘手。</p><p>本次分享将结合实际经验，介绍如何在不同场景下实现JWT的续签功能。</p><h2 id="为什么需要jwt续签" tabindex="-1"><a class="header-anchor" href="#为什么需要jwt续签" aria-hidden="true">#</a> 为什么需要JWT续签</h2><h3 id="jwt的基本流程" tabindex="-1"><a class="header-anchor" href="#jwt的基本流程" aria-hidden="true">#</a> JWT的基本流程</h3><ol><li>用户登录后，认证中心颁发JWT，并返回给客户端。</li><li>JWT包含用户基本信息和过期时间（Exp）。</li><li>客户端保存JWT，并在访问后台核心接口时附加在请求头或Cookie中。</li></ol><h3 id="jwt过期问题" tabindex="-1"><a class="header-anchor" href="#jwt过期问题" aria-hidden="true">#</a> JWT过期问题</h3><ul><li>JWT设置了过期时间（如30分钟）。</li><li>超过有效期后，后端校验JWT时会抛出403异常。</li><li>客户端接收到异常后，会将用户踢回登录页。</li></ul><img src="https://pic.hanjiaming.com.cn/2024/12/27/25fd595fbd44b.png" alt="1735305754022.png" style="zoom:50%;"><h3 id="不设置过期时间的风险" tabindex="-1"><a class="header-anchor" href="#不设置过期时间的风险" aria-hidden="true">#</a> 不设置过期时间的风险</h3><ul><li>长期/永久有效的JWT可能被恶意使用。</li><li>未设置过期时间的JWT会成为“太空垃圾”，带来安全隐患。</li></ul><h3 id="续签的必要性" tabindex="-1"><a class="header-anchor" href="#续签的必要性" aria-hidden="true">#</a> 续签的必要性</h3><ul><li>避免用户操作过程中被强制退出。</li><li>延长JWT的有效时间，提升用户体验。</li></ul><h3 id="续签的限制" tabindex="-1"><a class="header-anchor" href="#续签的限制" aria-hidden="true">#</a> 续签的限制</h3><ul><li>JWT续签必须有退出机制，避免无限续签导致的安全问题。</li></ul><h2 id="场景一-前台不允许改变-jwt-令牌" tabindex="-1"><a class="header-anchor" href="#场景一-前台不允许改变-jwt-令牌" aria-hidden="true">#</a> 场景一：前台不允许改变 JWT 令牌</h2><h3 id="解决方案-利用后台的redis" tabindex="-1"><a class="header-anchor" href="#解决方案-利用后台的redis" aria-hidden="true">#</a> 解决方案：利用后台的Redis</h3><figure><img src="https://pic.hanjiaming.com.cn/2024/12/27/a214fec9af7f3.png" alt="1735306265887.png" tabindex="0" loading="lazy"><figcaption>1735306265887.png</figcaption></figure><ol><li><p><strong>用户登录</strong>：</p><ul><li>认证中心颁发JWT，并向Redis中写入一个键值对。</li><li>键（Key）通过用户数据和客户端特征数据生成的MD5摘要。</li><li>值（Value）不重要，主要是设置Redis的过期时间（如2小时）。</li></ul></li><li><p><strong>客户端请求</strong>：</p><ul><li>客户端向后端服务发起请求，附带JWT。</li><li>后端服务校验JWT并提取用户ID和客户端特征数据，生成MD5摘要。</li><li>在Redis中查询该Key是否存在。</li></ul></li><li><p><strong>Redis校验</strong>：</p><ul><li>如果Key不存在，JWT无效，拒绝服务。</li><li>如果Key存在，查询剩余有效时间： <ul><li>超过1小时：正常响应。</li><li>少于1小时：续签1小时。</li></ul></li></ul></li><li><p><strong>退出机制</strong>：</p><ul><li>用户离开超过2小时，Redis中的Key过期被删除。</li><li>用户重新操作时，JWT无效，要求重新登录。</li></ul></li></ol><div class="hint-container tip"><p class="hint-container-title">为什么数据库使用 md5 作为 key?</p><ul><li>通过用户数据和客户端特征数据生成MD5摘要，提高安全性。</li><li>防止 JWT 被盗取后在不同环境下使用。</li></ul><p>改进方案：使用 JWT + 环境参数作为 key。</p></div><h3 id="优缺点" tabindex="-1"><a class="header-anchor" href="#优缺点" aria-hidden="true">#</a> 优缺点</h3><ul><li><strong>优点</strong>：利用Redis特性控制JWT有效时间，实现续签。</li><li><strong>缺点</strong>：JWT变为有状态，增加了系统复杂性。而不是那种随处可用的无状态。</li></ul><h2 id="_3-场景二-前台允许改变jwt令牌" tabindex="-1"><a class="header-anchor" href="#_3-场景二-前台允许改变jwt令牌" aria-hidden="true">#</a> 3. 场景二：前台允许改变JWT令牌</h2><h3 id="解决方案-使用两个jwt-access-token-和-refresh-token" tabindex="-1"><a class="header-anchor" href="#解决方案-使用两个jwt-access-token-和-refresh-token" aria-hidden="true">#</a> 解决方案：使用两个JWT（Access Token 和 Refresh Token）</h3><ol><li><p><strong>用户登录</strong>：</p><ul><li>认证中心返回两个JWT：Access Token和Refresh Token。</li><li>Access Token（如30分钟有效），主要用于业务交互。</li><li>Refresh Token（如60分钟有效），用于续签。</li></ul></li><li><p><strong>客户端请求</strong>：</p><ul><li>在请求头或Cookie中附带两个Token。</li><li>后端服务校验Access Token： <ul><li>有效：正常响应。</li><li>过期：校验Refresh Token。</li></ul></li></ul></li><li><p><strong>续签逻辑</strong>：</p><ul><li>Refresh Token有效：通过认证中心刷新生成新的Access Token和Refresh Token。</li><li>将新Token返回给客户端，替换旧Token。</li></ul></li><li><p><strong>退出机制</strong>：</p><ul><li>超过Refresh Token有效期（如1小时），要求重新登录。</li></ul></li></ol><h3 id="安全性考虑" tabindex="-1"><a class="header-anchor" href="#安全性考虑" aria-hidden="true">#</a> 安全性考虑</h3><ul><li>Refresh Token用于续签，解决Access Token失效后的续签问题。</li><li>防止无限续签，设置合理的过期时间。</li></ul><h3 id="优缺点-1" tabindex="-1"><a class="header-anchor" href="#优缺点-1" aria-hidden="true">#</a> 优缺点</h3><ul><li><strong>优点</strong>：轻量级实现，前端Token可变。</li><li><strong>缺点</strong>：客户端需要较大的改造工作，处理多个Token。</li></ul><h2 id="_4-解决重发jwt的问题" tabindex="-1"><a class="header-anchor" href="#_4-解决重发jwt的问题" aria-hidden="true">#</a> 4. 解决重发JWT的问题</h2><h3 id="问题描述" tabindex="-1"><a class="header-anchor" href="#问题描述" aria-hidden="true">#</a> 问题描述</h3><ul><li>多线程客户端可能同时发出多个请求，导致生成多个JWT。</li><li>可能出现Token覆盖或交叉写入问题。</li></ul><h3 id="解决方案-计时map数据结构" tabindex="-1"><a class="header-anchor" href="#解决方案-计时map数据结构" aria-hidden="true">#</a> 解决方案：计时Map数据结构</h3><ol><li><p><strong>认证中心设置计时Map</strong>：</p><ul><li>记录几秒内生成的JWT数据。</li><li>同样的JWT请求在短时间内返回相同的Token。</li></ul></li><li><p><strong>实现效果</strong>：</p><ul><li>避免多线程请求导致的Token覆盖或交叉写入问题。</li><li>提高系统的一致性和稳定性。</li></ul></li></ol><h2 id="_5-总结" tabindex="-1"><a class="header-anchor" href="#_5-总结" aria-hidden="true">#</a> 5. 总结</h2><ul><li>JWT续签可以提高用户体验，避免频繁登录。</li><li>不同场景下有不同的实现方案： <ul><li>前台不允许改变JWT：利用Redis控制有效时间。</li><li>前台允许改变JWT：使用Access Token和Refresh Token。</li></ul></li><li>续签方案需要考虑安全性和系统复杂性。</li><li>解决重发JWT的问题，确保系统的一致性。</li></ul><p>通过以上方案，可以在不同场景下实现JWT的续签功能，提高系统的安全性和用户体验。如果你有更好的方案，欢迎在评论区分享，大家一起拓宽思路。</p><p><strong>感谢大家的支持，记得点赞哦！</strong></p>',39),h=[n];function s(t,o){return e(),l("div",null,h)}const u=i(r,[["render",s],["__file","jwt-renew.html.vue"]]);export{u as default};
