import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as i,e as t}from"./app-771df221.js";const n={},r=t('<h1 id="virtual-memory" tabindex="-1"><a class="header-anchor" href="#virtual-memory" aria-hidden="true">#</a> Virtual Memory</h1><h2 id="introduce" tabindex="-1"><a class="header-anchor" href="#introduce" aria-hidden="true">#</a> Introduce</h2><p>Problem: if a program requires 1GB main memory, but we have only 1MB physical main memory, how can execute the program?「问题：如果一个程序需要1 GB的主内存，而我们只有1 MB的物理主内存，那么如何执行该程序？」</p><ul><li>1K = 2^10 = 1024</li><li>1M = 2^20 = 1024 * K</li><li>1G = 2^30 = 1024 * M</li><li>1T = 2^40 = 1024 * G</li></ul><p>Virtual memory, a technique that allows to fit the 1GB program into the 1MB physical main memory so that the program can execute</p><h3 id="program-image" tabindex="-1"><a class="header-anchor" href="#program-image" aria-hidden="true">#</a> Program Image</h3><img src="https://pic.hanjiaming.com.cn/2021/04/12/27372e7e8f0d5.png" alt="image.png" title="image.png"><p>The program image is <strong>too large</strong> to be fit into the main memory</p><img src="https://pic.hanjiaming.com.cn/2021/04/12/465d5e22644aa.png" alt="image.png" title="image.png"><h2 id="process" tabindex="-1"><a class="header-anchor" href="#process" aria-hidden="true">#</a> Process</h2><h3 id="executing-a-program" tabindex="-1"><a class="header-anchor" href="#executing-a-program" aria-hidden="true">#</a> Executing a program</h3><img src="https://pic.hanjiaming.com.cn/2021/04/12/0ecdca1996e51.png" alt="image.png" title="image.png"><h3 id="memory-access-in-program-execution" tabindex="-1"><a class="header-anchor" href="#memory-access-in-program-execution" aria-hidden="true">#</a> Memory access in program execution</h3><p>During execution, the CPU frequently goes to main memory to fetch data (instructions, data)「在执行期间，CPU经常进入主存储器以获取数据（指令，数据）」</p><img src="https://pic.hanjiaming.com.cn/2021/04/12/98085294a7f6f.png" alt="image.png" title="image.png"><h2 id="paging" tabindex="-1"><a class="header-anchor" href="#paging" aria-hidden="true">#</a> Paging</h2><ul><li>Chunk the program image into virtual pages「将程序映像分块为虚拟页面」</li><li>into physical pages, also called frames「将主内存分成物理页面，也称为框架」</li><li>Each time, load a page into a specific frame of the main memory「每次将页面加载到主存储器的特定帧中」</li></ul><p>Each time, load a page into a frame of the main memory</p><img src="https://pic.hanjiaming.com.cn/2021/04/12/756daafbe10c7.gif" alt="CleanShot 2021-04-12 at 23.24.12.gif" title="CleanShot 2021-04-12 at 23.24.12.gif"><p>Page 2 will use the physical address that has been used by Page 0</p><img src="https://pic.hanjiaming.com.cn/2021/04/12/a368ddf43940b.png" alt="image.png" title="image.png"><p>Issue 1: needs to remember which page is put into which frame<br> Page table: a mapping from virtual pages to frames</p><img src="https://pic.hanjiaming.com.cn/2021/04/12/d77b0fd8a7746.png" alt="image.png" title="image.png" width="300px"><p>Issue 2: if the memory is full, and a new page will be loaded, which old page to replace?</p><ul><li>Similar to cache</li><li>Many replacement policies, leveraging locality</li></ul><h3 id="page-table" tabindex="-1"><a class="header-anchor" href="#page-table" aria-hidden="true">#</a> Page table</h3><p>页表的大小是 Number of page table entries「页表条目数」</p><p>一般的，一行有一个条目「entires」</p><p>体积大小</p><ul><li>Page entry size = virtual page bits + physical page bits</li><li>Page table size = Number of page table entries * entries</li></ul><h2 id="general-address-translation" tabindex="-1"><a class="header-anchor" href="#general-address-translation" aria-hidden="true">#</a> General Address translation</h2><p>If I want to use a data item in my executable file, which has been loaded to main memory, how do I know the physical address of the data item?「如果要在可执行文件中使用已加载到主存储器中的数据项，我如何知道该数据项的物理地址？」</p><img src="https://pic.hanjiaming.com.cn/2021/04/12/c83c163dcb70b.png" alt="image.png" title="image.png"><p>To access “G” in physical main memory</p><ul><li>That is, to determine the physical address of “G”</li><li>Which page is “G” in? -&gt; page 1</li><li>Where is page 1 loaded to? -&gt; frame 3</li><li>What’s G’s offset in page 1? -&gt; 0x10 away for the start of page 1</li><li>Physical address = start address of frame 3 + G’s offset <ul><li>0x0100 + 0x10 = 0x0110</li></ul></li><li>Go to main memory with address 0x0110, you will get data item G</li></ul><img src="https://pic.hanjiaming.com.cn/2021/04/12/264a7ec07952c.png" alt="image.png" title="image.png"><h3 id="general-steps" tabindex="-1"><a class="header-anchor" href="#general-steps" aria-hidden="true">#</a> General steps</h3><p>我们在系统层面看到的都是虚拟地址。</p><ul><li>Virtual address (x) 由 page number (x) 和 offset (x) 组成</li><li>Check page table, page number (x) -&gt; frame number (x)</li><li>Frame number (x) -&gt; starting address (x)</li><li>Starting address (x) + offset (x) = physical address (x)</li></ul><p>If we want to access “b” which is in page 2. When we check the page table, do not find page 2 (page fault)</p><ul><li>page 2 has not been loaded into physical memory</li><li>load page 2 into main memory</li><li>if no space, kick out some old page</li><li>do address translation for b, get b’s physical address</li><li>fetch b from main memory to CPU</li></ul><h3 id="example" tabindex="-1"><a class="header-anchor" href="#example" aria-hidden="true">#</a> Example</h3><ul><li>Assume we use 24bits for an Virtual address</li><li>Assume the first virtual page/physical page is numbered from 0</li><li>In a paging system, the size of one page is <strong>1KB</strong></li></ul><p>1KB = 1024 Bytes = 2^10 bytes 我们需要10位来存储 offset (x)</p><p>剩下的 24-10 = 14位 来存储Page number</p><img src="https://pic.hanjiaming.com.cn/2021/04/27/79c3c0aa421cd.png" alt="image.png" title="image.png" width="500px"><img src="https://pic.hanjiaming.com.cn/2021/04/27/ea9d310438c02.png" alt="image.png" title="image.png" width="500px"><p>在Page Table里，我们只需记录 Virtual Page Number 。在每个Page里，每个条目的前14位相同。</p><img src="https://pic.hanjiaming.com.cn/2021/04/27/4778824fe581e.png" alt="image.png" title="image.png"><p>offset 用于表示偏差</p><img src="https://pic.hanjiaming.com.cn/2021/04/27/801e87826c490.png" alt="image.png" title="image.png"><h3 id="memory-management-unit" tabindex="-1"><a class="header-anchor" href="#memory-management-unit" aria-hidden="true">#</a> Memory Management Unit</h3><p>Address translation is done by a special hardware in CPU called Memory Management Unit (MMU)「地址转换由CPU中称为内存管理单元（MMU）的特殊硬件完成。」</p><ul><li>Address translation is too complex and slow</li><li>We need a fast worker to do the job</li></ul><img src="https://pic.hanjiaming.com.cn/2021/04/12/39cb0eaf72110.png" alt="image.png" title="image.png"><h3 id="translation-lookaside-buffer" tabindex="-1"><a class="header-anchor" href="#translation-lookaside-buffer" aria-hidden="true">#</a> Translation lookaside buffer</h3><p>Accessing page table in main memory is slow</p><p>Translation lookaside buffer (TLB): a cache for page table in the CPU chip</p><img src="https://pic.hanjiaming.com.cn/2021/04/12/c79e4bff4996e.png" alt="image.png" title="image.png"><h2 id="other-question" tabindex="-1"><a class="header-anchor" href="#other-question" aria-hidden="true">#</a> Other question</h2><p>VM as a way for memory management「VM作为内存管理的一种方式」</p><ul><li>The need for memory management <ul><li>There are multiple processes in the system sharing the memory</li><li>Memory space is generally insufficient for all the processes</li></ul></li><li>Targets of memory management <ul><li>How to allocate memory space to concurrent processes?「如何为并发进程分配内存空间？」 <ul><li>Space efficiency</li></ul></li><li>How to provide protection so that process A cannot access the data of process B?「如何提供保护，以使进程A无法访问进程B的数据？」</li></ul></li></ul><h3 id="memory-allocation-to-multiple-processes" tabindex="-1"><a class="header-anchor" href="#memory-allocation-to-multiple-processes" aria-hidden="true">#</a> Memory allocation to multiple processes</h3><p>Memory allocation for multiple processes「多个进程的内存分配」</p><ul><li>Each process can use a specific amount of physical pages「每个过程可以使用特定数量的物理页面」</li><li>Each virtual page can be mapped to any physical page「每个虚拟页面都可以映射到任何物理页面」</li><li>A virtual page can be stored in different physical pages at different times「虚拟页面可以在不同时间存储在不同的物理页面中」</li></ul><img src="https://pic.hanjiaming.com.cn/2021/04/12/2186dff0b0798.png" alt="image.png" title="image.png"><h3 id="memory-protection" tabindex="-1"><a class="header-anchor" href="#memory-protection" aria-hidden="true">#</a> Memory protection</h3><ul><li>Extend page table entries with permission bits</li><li>MMU will check these bits on each access</li></ul><img src="https://pic.hanjiaming.com.cn/2021/04/12/83eb5ce4447a4.png" alt="image.png" title="image.png"><h2 id="引用" tabindex="-1"><a class="header-anchor" href="#引用" aria-hidden="true">#</a> 引用</h2><ul><li>COMP1411&#39;s PowerPoint</li></ul>',71),l=[r];function s(o,m){return a(),i("div",null,l)}const h=e(n,[["render",s],["__file","Virtual-Memory.html.vue"]]);export{h as default};
