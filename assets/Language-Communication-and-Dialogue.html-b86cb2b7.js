import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as e,e as n}from"./app-fa1b5150.js";const l={},s=n(`<h1 id="language-communication-dialogue" tabindex="-1"><a class="header-anchor" href="#language-communication-dialogue" aria-hidden="true">#</a> Language &amp; Communication &amp; Dialogue</h1><h2 id="interface-hall-of-shame" tabindex="-1"><a class="header-anchor" href="#interface-hall-of-shame" aria-hidden="true">#</a> Interface Hall of Shame</h2><ul><li>提出充分和可理解的信息</li><li>提供 &quot;真正的 &quot;选择（用于解决问题）</li><li>避免含糊不清或自相矛盾的情况</li><li>节省用户的时间和精力</li></ul><img src="https://pic.hanjiaming.com.cn/2022/10/29/32f00225c411d.png" alt="1667027556068.png" style="zoom:33%;"><h2 id="talking-to-machines" tabindex="-1"><a class="header-anchor" href="#talking-to-machines" aria-hidden="true">#</a> Talking to Machines</h2><p>Coding language: 计算机和普通机器的根本区别在于，计算机可以通过语言来接近</p><p>Programming languages come in a variety of levels:</p><ul><li>低层次：机器码、汇编等</li><li>高级别的：Java, Python, Ruby等</li><li>编译器将 语言 X 翻译成 语言 Y（例如，objective-c 到 Swift）</li><li>程序 到 另一个程序（原定义：高层到机器语言）</li><li>编程规范</li><li>将图形 转化为 程序（即可视化编程）</li><li>程序/规范 到 硬件</li></ul><h2 id="fortran的诞生" tabindex="-1"><a class="header-anchor" href="#fortran的诞生" aria-hidden="true">#</a> FORTRAN的诞生</h2><p>John Backus 开发了 Speedcoding：一种解释性语言，在 IBM 701上运行时比手写的汇编慢20倍。</p><ul><li>Backus的目标：将高级语言翻译成汇编语言</li><li>很多人认为这是不可能的：Backus 之前在其他项目中都失败过</li><li>1954-7年标志着FORTRAN I项目</li><li>到 1958 年：&gt; 50% 的软件都在 FORTRAN 中</li><li>开发时间从几周缩短到几小时</li></ul><div class="hint-container info"><p class="hint-container-title">Sample Code in FORTRAN</p><p>你从来没有学过FORTRAN，但你可以理解它！</p><div class="language-fortran line-numbers-mode" data-ext="fortran"><pre class="language-fortran"><code><span class="token keyword">program</span> addNumbers

	<span class="token comment">! This simple program adds two numbers </span>
	<span class="token keyword">implicit none</span>
	
  <span class="token comment">! Type declarations</span>
  <span class="token keyword">real</span> <span class="token operator">::</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token keyword">result</span>
  
	<span class="token comment">! Executable statements </span>
	a <span class="token operator">=</span> <span class="token number">12.0</span>
	b <span class="token operator">=</span> <span class="token number">15.0</span>
	<span class="token keyword">result</span> <span class="token operator">=</span> a <span class="token operator">+</span> b
	
	<span class="token keyword">print</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token string">&#39;The total is &#39;</span><span class="token punctuation">,</span> <span class="token keyword">result</span> 
	
<span class="token keyword">end program</span> addNumbers
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><h2 id="解释与预先编撰" tabindex="-1"><a class="header-anchor" href="#解释与预先编撰" aria-hidden="true">#</a> 解释与预先编撰</h2><p>尽管速度较慢，但 Speedcoding 和后来的 FORTRAN 如何在 1950 年代后期占据大部分软件编程？以牺牲系统资源为代价，注重使用的便利性。</p><ul><li><strong>Just in time compilation</strong>：（常规）解释器一次只翻译一个程序语句</li><li><strong>Ahead of time compilation</strong>：将整个程序一次性翻译成机器代码</li><li>许多现代编程语言融合了两种方法（例如，Java）</li></ul><img src="https://pic.hanjiaming.com.cn/2022/10/29/32bbf6cdb0337.png" alt="1667029410881.png" style="zoom:33%;"><p>解释（及时编译）和（提前）编译的优点和缺点？</p><ul><li>Cross platform</li><li>Compiling time</li><li>Execution efficiency「执行效率」</li></ul><img src="https://pic.hanjiaming.com.cn/2022/10/29/c0adb112a63c7.png" alt="1667029804139.png" style="zoom:50%;"><h2 id="compiler-architecture" tabindex="-1"><a class="header-anchor" href="#compiler-architecture" aria-hidden="true">#</a> Compiler Architecture</h2><p>汇编的两个阶段：</p><ul><li>分析阶段：将源程序分解为多个部分以构建中间表示 <ul><li>Lexical Analysis</li><li>Syntax Analysis</li><li>Semantic Analysis</li></ul></li><li>综合阶段：从中间表示生成目标程序 <ul><li>Intermediate Code Generator</li><li>Code Optimizer</li><li>Code Generator</li></ul></li></ul><img src="https://pic.hanjiaming.com.cn/2022/10/29/596af819bcabd.png" alt="1667030086412.png" style="zoom:33%;"><h2 id="编码语言-缺点" tabindex="-1"><a class="header-anchor" href="#编码语言-缺点" aria-hidden="true">#</a> 编码语言 - 缺点</h2><p>编码语言曾经是计算机的唯一界面。今天，编程语言会成为一个好的用户界面吗？</p><figure><img src="https://pic.hanjiaming.com.cn/2022/10/29/600d987cf59d7.png" alt="1667030611526.png" tabindex="0" loading="lazy"><figcaption>1667030611526.png</figcaption></figure><h2 id="dialogue-design" tabindex="-1"><a class="header-anchor" href="#dialogue-design" aria-hidden="true">#</a> Dialogue Design</h2><h3 id="example" tabindex="-1"><a class="header-anchor" href="#example" aria-hidden="true">#</a> Example</h3><ul><li>System presents an output observed by the user who performs a task「系统呈现出一个由执行任务的用户观察到的输出」</li><li>User articulates an input that makes the system perform「用户阐述一个输入，使系统执行。」</li></ul><img src="https://pic.hanjiaming.com.cn/2022/10/29/a6b391bf86325.png" alt="1667030749143.png" style="zoom:33%;"><h3 id="what" tabindex="-1"><a class="header-anchor" href="#what" aria-hidden="true">#</a> What</h3><p>对话是两方或多方之间的对话，通常是合作的。</p><ul><li>In user interfaces <ul><li>指的是互动的 逻辑/结构「logic/structure」</li><li>句法层面的人机 &quot;对话&quot;</li></ul></li><li>Levels <ul><li>Lexical「词汇」：图标的形状、实际按下的键、字符</li><li>Syntactic「句法」：输入和输出的顺序（击键、点击）</li><li>Semantic「语义」：对内部应用/数据的影响，击键的意义，点击的意义</li></ul></li></ul><h3 id="why" tabindex="-1"><a class="header-anchor" href="#why" aria-hidden="true">#</a> Why</h3><p>「Dialog notations」对话符号帮助我们</p><ul><li>分析系统</li><li>将词汇和语义分开</li></ul><p>在系统建立之前：对话符号「Dialog notations」帮助我们理解提议的设计（即快速原型制作）</p><p>与客户/利益相关者讨论你的系统</p><ul><li>将想法转化为代码</li><li>Systematic testing「系统性测试」</li><li>1000% 的 生产力提高</li><li>Formalism saves time「形式主义节省了时间」</li></ul><h3 id="prototyping" tabindex="-1"><a class="header-anchor" href="#prototyping" aria-hidden="true">#</a> Prototyping</h3><img src="https://pic.hanjiaming.com.cn/2022/10/29/fbb847571b37f.png" alt="1667031538000.png" style="zoom:50%;"><h3 id="how" tabindex="-1"><a class="header-anchor" href="#how" aria-hidden="true">#</a> How</h3><p>人机对话「dialogues」是非常受限制的「constrained」。一些人与人之间的对话也是非常受限制的（例如，法律、财务）。</p><p>我们如何描述对话（“符号”）？</p><ul><li>State Transition Networks (STN)</li><li>State diagrams (UML)</li><li>Flow charts</li><li>Petri nets</li><li>JSD diagrams (Jackson Structured Design Diagrams)</li><li>Formal Grammars</li><li>Production Rules</li></ul><h2 id="状态转换网络-stn" tabindex="-1"><a class="header-anchor" href="#状态转换网络-stn" aria-hidden="true">#</a> 状态转换网络（STN）</h2><p>Formal descriptions to analyze</p><ul><li>Inconsistency「不连贯性」</li><li>Reversibility「可逆性」</li><li>Completeness「完整性」</li><li>Potential errors「潜在的错误」</li></ul><p>State Transition Networks (STNs) 「状态转换网络（STNs）」</p><ul><li>Circles: States</li><li>Arcs: Actions/Events</li></ul><img src="https://pic.hanjiaming.com.cn/2022/10/29/21e1d0a8e8d8f.png" alt="1667035836286.png" style="zoom:50%;"><h3 id="hierarchical-stns" tabindex="-1"><a class="header-anchor" href="#hierarchical-stns" aria-hidden="true">#</a> Hierarchical STNs</h3><ul><li>只是一个STN在另一个STN里面</li><li>Named sub-dialogs「命名的子对话框」</li><li>对管理复杂的对话至关重要</li></ul><p>Hierarchical STNs</p><ul><li>Circles: States</li><li>Arcs: Actions/Events</li><li>Rectangles: sub-STN</li></ul><img src="https://pic.hanjiaming.com.cn/2022/10/29/ac4a275a0089e.png" alt="1667036161482.png" style="zoom:50%;"><h3 id="stn-concurrent-dialogues" tabindex="-1"><a class="header-anchor" href="#stn-concurrent-dialogues" aria-hidden="true">#</a> STN - Concurrent Dialogues</h3><ul><li>Several things happen simultaneously「有几件事同时发生」</li><li>示例：用于文本格式的简单对话框</li></ul><img src="https://pic.hanjiaming.com.cn/2022/10/29/50db190b8b583.png" alt="1667036499052.png" style="zoom:33%;"><ul><li>Put STNs together</li><li>谨防组合爆炸「Beware of combinatorial explosion」</li></ul><figure><img src="https://pic.hanjiaming.com.cn/2022/10/29/7f83ccf460a13.png" alt="1667036597447.png" tabindex="0" loading="lazy"><figcaption>1667036597447.png</figcaption></figure><h3 id="stn-design-of-escapes" tabindex="-1"><a class="header-anchor" href="#stn-design-of-escapes" aria-hidden="true">#</a> STN - Design of Escapes</h3><ul><li>Web中的&#39;返回&#39;，Escape/Cancel键 <ul><li>到处都有类似的行为</li><li>End up with spaghetti of identical behaviors!</li></ul></li><li>How do we show this? <ul><li>使用分层菜单：每个子菜单的“正常”退出加上</li><li>分离逃生弧在子菜单中“无处不在”</li></ul></li></ul><figure><img src="https://pic.hanjiaming.com.cn/2022/10/29/ea6697ac77b7f.png" alt="1667036956469.png" tabindex="0" loading="lazy"><figcaption>1667036956469.png</figcaption></figure><h3 id="stn-design-of-help-menus" tabindex="-1"><a class="header-anchor" href="#stn-design-of-help-menus" aria-hidden="true">#</a> STN - Design of Help Menus</h3><ul><li>各地的菜单结构几乎相同。</li><li>回到对话中的同一点可以在 STN 上指定，但非常混乱。Usually best added at a ‘meta’ level.</li></ul><figure><img src="https://pic.hanjiaming.com.cn/2022/10/30/3f36afcb87442.png" alt="1667125192017.png" tabindex="0" loading="lazy"><figcaption>1667125192017.png</figcaption></figure><h2 id="state-diagram-uml" tabindex="-1"><a class="header-anchor" href="#state-diagram-uml" aria-hidden="true">#</a> State Diagram (UML)</h2><figure><img src="https://pic.hanjiaming.com.cn/2022/12/10/a3a13515aea15.png" alt="1670669628809.png" tabindex="0" loading="lazy"><figcaption>1670669628809.png</figcaption></figure><h2 id="flow-charts" tabindex="-1"><a class="header-anchor" href="#flow-charts" aria-hidden="true">#</a> Flow charts</h2><figure><img src="https://pic.hanjiaming.com.cn/2022/12/10/ba779fa7a387b.png" alt="1670669668673.png" tabindex="0" loading="lazy"><figcaption>1670669668673.png</figcaption></figure><h2 id="nature-language-processing" tabindex="-1"><a class="header-anchor" href="#nature-language-processing" aria-hidden="true">#</a> Nature Language Processing</h2><h3 id="信息处理模式" tabindex="-1"><a class="header-anchor" href="#信息处理模式" aria-hidden="true">#</a> 信息处理模式</h3><ul><li>人类作为信息处理机器</li><li>现在的计算机通过多种感官渠道与我们交流</li></ul><figure><img src="https://pic.hanjiaming.com.cn/2022/12/10/fc8d622bd3494.png" alt="1670669817390.png" tabindex="0" loading="lazy"><figcaption>1670669817390.png</figcaption></figure><h3 id="implications" tabindex="-1"><a class="header-anchor" href="#implications" aria-hidden="true">#</a> Implications</h3><ul><li>提出的信息量：虽然大量的信息通过我们的五种感官进入，但我们可以在同一时间内专注于少量的信息。</li><li>需要如何重复介绍：在感觉输入和长期记忆之间建立联系</li><li>现在，许多大公司（如谷歌）使用定量方法（如眼睛注视数据）来研究GUI设计</li></ul><h3 id="mismatch-between-user-and-system-models" tabindex="-1"><a class="header-anchor" href="#mismatch-between-user-and-system-models" aria-hidden="true">#</a> Mismatch Between User and System Models</h3><p>执行的鸿沟</p><ul><li>用户的意图和允许的行动之间的不匹配</li><li>&quot;我如何使用该系统？&quot;</li></ul><p>评价的鸿沟</p><ul><li>用户的期望和系统的表述之间的差异</li><li>&quot;当前的系统状态是什么？&quot;</li></ul><h3 id="响应时间" tabindex="-1"><a class="header-anchor" href="#响应时间" aria-hidden="true">#</a> 响应时间</h3><ul><li>系统处理输入和呈现输出的时间</li><li>异常长的响应时间可能会导致 <ul><li>用户挫败感</li><li>错误输入</li><li>效率较低（这与引入GUI的目标相矛盾）</li></ul></li></ul>`,84),t=[s];function r(o,c){return a(),e("div",null,t)}const h=i(l,[["render",r],["__file","Language-Communication-and-Dialogue.html.vue"]]);export{h as default};
