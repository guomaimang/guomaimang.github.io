import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as l,c as t,e as n,a as i,b as a}from"./app-6763ed11.js";const s={},r=n('<h1 id="数位系统以及其算法3" tabindex="-1"><a class="header-anchor" href="#数位系统以及其算法3" aria-hidden="true">#</a> 数位系统以及其算法3</h1><h2 id="fractional-binary-numbers" tabindex="-1"><a class="header-anchor" href="#fractional-binary-numbers" aria-hidden="true">#</a> Fractional binary numbers</h2><p>Fractional binary numbers 分数二进制数</p><ul><li><p>Fractional decimal numbers</p><ul><li>11.62510 = 1 * 101 + 1 * 100 + 6 * 10-1 + 2<em>10-2 + 5</em>10-3</li><li>Precision: 10-3</li></ul></li><li><p>Fractional binary numbers</p><ul><li>1011.1012 = 1 * 23 + 0 * 22 + 1 * 21 + 1 * 20 + 1 * 2-1 + 0 * 2-2 + 1 * 2-3</li><li>11.625 = 8 + 2 + 1 + 1/2 + 1/8</li><li>Precision: 2-3</li></ul></li></ul><p><strong>对于二进制浮点数，有</strong></p><figure><img src="https://pic.hanjiaming.com.cn/2021/02/20210205044012378.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="转换公式" tabindex="-1"><a class="header-anchor" href="#转换公式" aria-hidden="true">#</a> 转换公式</h3><p>十进制数 =</p><img src="https://pic.hanjiaming.com.cn/2021/02/20210205044036196.png" width="100px"><h3 id="举例" tabindex="-1"><a class="header-anchor" href="#举例" aria-hidden="true">#</a> 举例</h3><ul><li>53/4 = 101.112</li><li>27/8 = 10.1112</li><li>17/16 = 1.01112</li></ul><p><strong>观察结果</strong></p><ul><li>右移除以2（无符号）</li><li>左移乘以2</li><li>格式为0.1111111…2的数字小于1.0</li></ul><h3 id="局限性" tabindex="-1"><a class="header-anchor" href="#局限性" aria-hidden="true">#</a> 局限性</h3><h4 id="limitation-1" tabindex="-1"><a class="header-anchor" href="#limitation-1" aria-hidden="true">#</a> Limitation #1</h4><ul><li><p>Can only exactly represent numbers of the form x*(2^k)</p><ul><li>Values that cannot be exactly represented:</li><li>1/3 0.0101010101[01]…2 <ul><li>1/5 0.001100110011[0011]…2</li><li>1/10 0.0001100110011[0011]…2</li></ul></li></ul></li></ul><h4 id="limitation-2" tabindex="-1"><a class="header-anchor" href="#limitation-2" aria-hidden="true">#</a> Limitation #2</h4><img src="https://hongshupic.oss-cn-zhangjiakou.aliyuncs.com/2021/02/26/db914692d2e3a.png" alt="CleanShot 2021-02-26 at 12.28.40@2x.png" title="CleanShot 2021-02-26 at 12.28.40@2x.png"><h2 id="ieee-floating-point" tabindex="-1"><a class="header-anchor" href="#ieee-floating-point" aria-hidden="true">#</a> IEEE Floating Point</h2><ul><li><p>IEEE Standard 754</p></li><li><ul><li>Many machines were having different floating point representations, then in 1985, IEEE established a uniform standard for floating point arithmetic</li><li>Nowadays, supported by all major CPUs</li></ul></li><li><p>Driven by numerical concerns</p></li><li><ul><li><p>Nice standards for rounding, overflow, underflow</p></li><li><p>Hard to make fast in hardware</p></li><li><ul><li>Numerical analysts predominated over hardware designers in defining standard</li></ul></li></ul></li></ul><h2 id="floating-point-representation" tabindex="-1"><a class="header-anchor" href="#floating-point-representation" aria-hidden="true">#</a> Floating Point Representation</h2><p>上一节我们已经说过，小数由二进制转换成10进制可以这样</p><figure><img src="https://pic.hanjiaming.com.cn/2021/01/20210125170026209.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>那么，现在我们遇到了问题，在计算机里，这个小数点放到哪里？</p><p>如果小数点位于固定位置，则数据范围非常有限（不灵活）</p><p>那么，类比十进制的科学计数法</p>',26),o=i("p",{"-14":""},[a("976,000,000,000,000 → 9.76 x 10^{14}"),i("br"),a(" 0.0000000000000976 → 9.76 x 10^")],-1),c=n('<p>我们所做的：动态地将小数点滑动到一个方便的位置，并使用10的指数来跟踪该位置，使用这种相似的想法来表示计算机中的二进制小数。</p><p>是的，计算机中存储小数是以 科学计数法的二进制数值 转换成二进制码 存储。</p><h3 id="浮点-ft-表示" tabindex="-1"><a class="header-anchor" href="#浮点-ft-表示" aria-hidden="true">#</a> 浮点（FT）表示</h3><p>代表相同数字的方式有多种，如下图</p><img src="https://pic.hanjiaming.com.cn/2021/01/20210125170700316.png" width="150px"><p>但是，对于浮点表示，有 两个惯例：<br> （1）小数点位于左侧的最右边-大多数位（小数点的左侧只有一位）<br> （2）左边-有效位数的最高位数不为零（对于基数2，始终为1）-归一化<br> 结果，标准化的非零数始终具有以下形式：</p><img src="https://pic.hanjiaming.com.cn/2021/01/20210125170842540.png" width="150px"><p>结果，我们不需要将“ 1”存储在有效位中，只需存储bbbbbbbbbb，毕竟只要是一个这样小数通过这样的方法表示，首位都是1.</p><h3 id="偏指数e-以单精度举例" tabindex="-1"><a class="header-anchor" href="#偏指数e-以单精度举例" aria-hidden="true">#</a> 偏指数E（以单精度举例）</h3><p>单精度浮点数可以这样存储</p><ul><li>第1位：Sign of significand，长度为1，记录正负</li><li>第2-9：Biased exponent （偏指数），长度为8，记录偏指数</li><li>第10-32位：Significand，（长度为23），记录bbbbbbbbbb…</li></ul><figure><img src="https://pic.hanjiaming.com.cn/2021/01/20210125171141987.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li>Biased exponent 中存的是 偏差指数。</li><li>偏差指数(exp) = E的实际值 + 固定偏差(2^(k-1)-1)</li><li>固定偏差：2 ^ {k-1}-1 <ul><li>k是“ Biased exponent”字段的位数，这个案例中，k = 8</li><li>例如：k = 8，偏差= 2 ^ 7-1 = 127；</li><li>如果E = 10100 = 20，则 偏差指数 = E + 偏差= 147 = 1001 0011(通过二进制无符号规则转化）</li></ul></li><li>因为有偏指数是从0到255，所以E在-127到128的范围内</li></ul><p>举例：</p><figure><img src="https://pic.hanjiaming.com.cn/2021/01/20210125171844903.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>举例：</p><p>二进制：-0.001010</p>',17),p=i("ul",null,[i("li",{"-3":""},"步骤1：规范化：-1.01 x 2 ^"),i("li",null,[a("步骤2：取得有偏指数： "),i("ul",null,[i("li",null,"E =-3"),i("li",null,"有偏指数=-3 + 127 = 124"),i("li",null,"124 转 二进制 0111 1100")])]),i("li",null,"第3步获得有效位数（23位）：01 0 0000 0000 0000 0000 0000"),i("li",null,"结果：1 0111 1100 010 0000 0000 0000 0000 0000 0000")],-1),d=n(`<img src="https://hongshupic.oss-cn-zhangjiakou.aliyuncs.com/2021/02/26/8665b61a03d28.png" alt="CleanShot 2021-02-26 at 12.34.02@2x.png" title="CleanShot 2021-02-26 at 12.34.02@2x.png"><h3 id="单精度变量和双精度变量的区别" tabindex="-1"><a class="header-anchor" href="#单精度变量和双精度变量的区别" aria-hidden="true">#</a> 单精度变量和双精度变量的区别</h3><ul><li>单精度长32位</li><li>双精度长64位</li></ul><figure><img src="https://pic.hanjiaming.com.cn/2021/01/20210129043408464.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="内存查看" tabindex="-1"><a class="header-anchor" href="#内存查看" aria-hidden="true">#</a> 内存查看</h3><img src="https://hongshupic.oss-cn-zhangjiakou.aliyuncs.com/2021/02/26/f958f97657f52.png" alt="CleanShot 2021-02-26 at 15.11.45@2x.png" title="CleanShot 2021-02-26 at 15.11.45@2x.png"><p>我们发现，每8个bit = 1个byte,所以我们看到的hex为465DB400</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>#include &lt;stdio.h&gt;

typedef unsigned char *pointer;

void show_bytes(pointer start, size_t len){
  size_t i;
  for (i = 0; i &lt; len; i++)
    printf(&quot;%p\\t0x%.2x\\n&quot;,start+i, start[i]);
  printf(&quot;\\n&quot;);
}

int main() {
    float a=15213;
    show_bytes((pointer)&amp;a,sizeof(float));
    return 0;
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用以上代码可以查看相应的地址中存储的数据。我们可以发现 float长32bits。</p><h3 id="denormalized-values" tabindex="-1"><a class="header-anchor" href="#denormalized-values" aria-hidden="true">#</a> Denormalized values</h3><p>when exp = 00000..000</p><img src="https://hongshupic.oss-cn-zhangjiakou.aliyuncs.com/2021/02/26/ee975dbad8932.png" alt="image.png" title="image.png"><ul><li>exp = 000…0, frac = 000..0 --&gt; zero value <ul><li>Note that s = 0/1, possitive/negative zero</li></ul></li><li>exp = 000…0, frac ≠ 000…0 --&gt; numbers closest to 0.0</li></ul><p>When: exp = 111…1</p><img src="https://hongshupic.oss-cn-zhangjiakou.aliyuncs.com/2021/02/26/5ac8f7349b5bf.png" alt="image.png" title="image.png"><ul><li>Case: exp = 111…1, frac = 000…0 <ul><li>Represents value --&gt; (infinity)</li><li>Operation that overflows: e.g., the result of 1.0/0.0</li></ul></li><li>Case: exp = 111…1, frac ≠ 000…0 <ul><li>Not-a-Number (NaN)</li><li>Represents case when no numeric value can be determined : E.g., the result of sqrt(-1)</li></ul></li></ul><h3 id="example" tabindex="-1"><a class="header-anchor" href="#example" aria-hidden="true">#</a> Example</h3><img src="https://hongshupic.oss-cn-zhangjiakou.aliyuncs.com/2021/02/26/6b8007cb12ff5.png" alt="image.png" title="image.png"><p>我们发现当s = 0的时候，以字符串拼合 &quot;exp&quot; + &quot;frac&quot; 的值看做unsigned的话总是在随着value的增加而增加。这就表明，这可以用于快速比较两个float的大小（特殊的编码除外）。</p><p>如果位数过长会发生截断，这个时候会使用IEEE标准来截断，使用round even。</p><h3 id="二进制浮点数的范围" tabindex="-1"><a class="header-anchor" href="#二进制浮点数的范围" aria-hidden="true">#</a> 二进制浮点数的范围</h3><p>对于</p><img src="https://pic.hanjiaming.com.cn/2021/01/20210125172622678.png" width="150px"><figure><img src="https://pic.hanjiaming.com.cn/2021/01/20210125172647281.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>由上图可知</p><p>32 bit 系统中，能精确表示的正小数为 2^（-127） 到 {2<sup>-[2</sup>(-23)]} * 128，负小数为- {2<sup>-[2</sup>(-23)]} * 128 到2^（-127）。</p><p>其实，你可以这样理解，计算机的小数存储就像一把特殊的有精度的刻度尺。</p><p><img src="https://pic.hanjiaming.com.cn/2021/01/20210125173129946.png" alt="img" loading="lazy">它们是直线上的离散点</p><ul><li>它们不是均匀分布的：接近0时是密集的</li></ul><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h3><img src="https://hongshupic.oss-cn-zhangjiakou.aliyuncs.com/2021/02/26/8665b61a03d28.png" alt="CleanShot 2021-02-26 at 12.34.02@2x.png" title="CleanShot 2021-02-26 at 12.34.02@2x.png"><img src="https://hongshupic.oss-cn-zhangjiakou.aliyuncs.com/2021/02/26/de228d29e4cb1.png" alt="CleanShot 2021-02-26 at 15.09.46@2x.png" title="CleanShot 2021-02-26 at 15.09.46@2x.png"><img src="https://hongshupic.oss-cn-zhangjiakou.aliyuncs.com/2021/02/26/bae694700bd84.png" alt="CleanShot 2021-02-26 at 15.26.10@2x.png" title="CleanShot 2021-02-26 at 15.26.10@2x.png"><img src="https://hongshupic.oss-cn-zhangjiakou.aliyuncs.com/2021/02/26/ade368a91ac2b.png" alt="CleanShot 2021-02-26 at 15.54.45@2x.png" title="CleanShot 2021-02-26 at 15.54.45@2x.png">`,34),h=[r,o,c,p,d];function u(g,m){return l(),t("div",null,h)}const x=e(s,[["render",u],["__file","digital-system3.html.vue"]]);export{x as default};
