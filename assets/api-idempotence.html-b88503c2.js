import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as a,e as n}from"./app-a1c6ff48.js";const r={},o=n('<h1 id="分布式设计中的幂等性处理" tabindex="-1"><a class="header-anchor" href="#分布式设计中的幂等性处理" aria-hidden="true">#</a> 分布式设计中的幂等性处理</h1><p>在<strong>分布式系统</strong>设计中，接口幂等性的处理是必须要考虑的重要问题。</p><p>很多开发人员对幂等性了解不多，在实际代码开发中也很少关注。</p><p><strong>其实幂等性的概念非常简单，它的含义是：一次接口调用与多次相同的接口调用，能够得到与预期相符的结果。</strong></p><h2 id="基本架构设计案例" tabindex="-1"><a class="header-anchor" href="#基本架构设计案例" aria-hidden="true">#</a> 基本架构设计案例</h2><p>以京东金融为例，京东金融有大量的应用系统，比如审计系统和前端应用。它们需要与后台的数据仓库进行交互，通常选择 RESTful 或 RPC 的方式进行调用。这里以 RESTful 为例进行讲解。</p><figure><img src="https://pic.hanjiaming.com.cn/2024/12/27/59692e801db98.png" alt="1735284799165.png" tabindex="0" loading="lazy"><figcaption>1735284799165.png</figcaption></figure><p>系统之间通过网络传输，网络可能会出现断网的情况。为了保证系统的高可靠性，前端应用系统可能会增加如 <strong>Spring Retryable</strong> 这样的组件，通过不断重试发送相同调用消息的方式来提高系统的可靠性。</p><p><u>这种方式会带来一个附加问题：后台服务必须考虑幂等性。</u></p><h2 id="案例分析" tabindex="-1"><a class="header-anchor" href="#案例分析" aria-hidden="true">#</a> 案例分析</h2><img src="https://pic.hanjiaming.com.cn/2024/12/27/eb76e599882ae.png" alt="1735284874073.png" style="zoom:25%;"><p>假设有一个RESTful接口用于将编号为1的员工的工资上调500元。很多新手程序员会这样写代码：</p><img src="https://pic.hanjiaming.com.cn/2024/12/27/decea10f61c6a.png" alt="1735285080877.png" style="zoom:25%;"><ol><li>从数据库中通过 <code>select by ID</code> 得到当前员工的基本工资信息。</li><li>用 <code>EMP.setSalary</code> 在原有工资基础上加上参数中的500。</li><li>执行更新操作。</li></ol><p>单看这三行代码没有问题，但忽略了接口的幂等性处理。</p><p>如果前端应用为了保证高可用，通过底层组件发送了多次重复请求，每执行一次，员工的工资就会增加500，执行十次则增加5000。预期是在原始工资基础上加500，但实际可能加了5000，这就破坏了幂等性。</p><h2 id="解决方案" tabindex="-1"><a class="header-anchor" href="#解决方案" aria-hidden="true">#</a> 解决方案</h2><h3 id="传统解决方案" tabindex="-1"><a class="header-anchor" href="#传统解决方案" aria-hidden="true">#</a> 传统解决方案</h3><p>在业务代码上进行前置判断，通过数据库中的标识判断员工是否已经调过薪，或者记录上次调薪的时间来进行判断。这种方法有两个问题：</p><ol><li><u>需要做前置幂等判断的地方可能太多，容易漏掉。</u></li><li>增加程序员的工作量和复杂度，特别是对实习工程师来说，难以保证他们能考虑到幂等性的问题。</li></ol><h3 id="无侵入的幂等解决方案" tabindex="-1"><a class="header-anchor" href="#无侵入的幂等解决方案" aria-hidden="true">#</a> 无侵入的幂等解决方案</h3><p>构建一个与业务无关的通用幂等解决方案，称为幂等表。幂等表的设计如下：</p><ol><li><strong>增加两个组件</strong>：应用网关 和 Redis。</li><li><strong>应用网关职责</strong>：对应用发来的请求进行过滤和转发。</li><li><strong>Redis职责</strong>：存储最近执行的请求编号。</li></ol><p>构建幂等表 in redis 是我们的通用解决方案。</p><h3 id="处理过程" tabindex="-1"><a class="header-anchor" href="#处理过程" aria-hidden="true">#</a> 处理过程</h3><figure><img src="https://pic.hanjiaming.com.cn/2024/12/27/e8a2ced781a38.png" alt="1735286170879.png" tabindex="0" loading="lazy"><figcaption>1735286170879.png</figcaption></figure><ol><li><strong>请求编号生成</strong>：前端应用系统在每次发送 RESTful 或 RPC 调用时，在请求头或RPC头部附加一个唯一的 <code>request ID</code>。</li><li><strong>网关检查</strong>：请求到达网关，网关通过 Nginx 和 Lua 脚本检查 Redis 中的幂等表。如果 <code>request ID</code> 不存在，保存到幂等表中，状态设置为 <code>proc</code>（处理中）。</li><li><strong>请求处理</strong>：业务逻辑处理完成后，更新Redis中的 <code>request ID</code> 状态为 <code>OK</code>（处理成功）。</li></ol><figure><img src="https://pic.hanjiaming.com.cn/2024/12/27/738be0cf6f61f.png" alt="1735286457321.png" tabindex="0" loading="lazy"><figcaption>1735286457321.png</figcaption></figure><p><strong>重复请求处理</strong>：如果相同的 <code>request ID</code> 再次发送，网关直接返回错误编码 201，前端应用接收到 201 编码后排除本次请求。</p><div class="hint-container warning"><p class="hint-container-title">考虑 redis 突然断网怎么办</p><p>潜在的影响</p><ul><li>redis 断网</li><li>新的重试被拒绝，应用系统显示处理失败</li><li>数据服务的数据变更执行完成</li><li>无法把 ok 写到 redis</li></ul><p>不妨先写 ok 入redis，再执行数据变更业务。</p></div><h3 id="存活时间的设置" tabindex="-1"><a class="header-anchor" href="#存活时间的设置" aria-hidden="true">#</a> 存活时间的设置</h3><p>Redis中的幂等表数据设置存活时间（如5分钟），作用有两个：</p><ol><li><strong>防止内存占用过多</strong>：及时清除过期数据，释放内存。</li><li><strong>处理异常情况</strong>：数据服务在处理中途崩溃，导致请求一直处于处理中状态，存活时间到期后数据被清除，允许再次处理请求。</li></ol><h3 id="代码实现" tabindex="-1"><a class="header-anchor" href="#代码实现" aria-hidden="true">#</a> 代码实现</h3><p>通过AOP（面向切面编程）实现无侵入的幂等处理：</p><ol><li><strong>注解定义</strong>：在控制器方法上增加自定义注解。</li><li><strong>AOP拦截</strong>：AOP在方法执行后，通过后置通知更新Redis中的 <code>request ID</code> 状态。</li></ol><img src="https://pic.hanjiaming.com.cn/2024/12/27/a069245f14f7e.png" alt="1735287438788.png" style="zoom:25%;"><h2 id="优缺点分析" tabindex="-1"><a class="header-anchor" href="#优缺点分析" aria-hidden="true">#</a> 优缺点分析</h2><h3 id="优点" tabindex="-1"><a class="header-anchor" href="#优点" aria-hidden="true">#</a> 优点</h3><ol><li><strong>无代码侵入</strong>：无需修改业务逻辑，只需增加注解即可。</li><li><strong>通用性强</strong>：适用于所有系统，保证接口幂等性。</li></ol><h3 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点" aria-hidden="true">#</a> 缺点</h3><ol><li><strong>前台改造</strong>：要求在请求头中附带唯一的请求编号，并处理自定义错误编码201。</li><li><strong>架构复杂度增加</strong>：增加了Nginx和Redis组件，可能增加运营和开发成本。</li></ol><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>幂等表的设计通过Redis和应用网关，确保每个业务请求只被处理一次，避免重复请求带来的问题。</p><p>虽然增加了一些架构复杂度，但提供了一个通用的解决方案，适用于多个系统。</p>',45),t=[o];function d(s,l){return e(),a("div",null,t)}const p=i(r,[["render",d],["__file","api-idempotence.html.vue"]]);export{p as default};
