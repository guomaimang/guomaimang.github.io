import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r,o as d,c as o,a as i,b as a,d as n,e as l}from"./app-2dd07df6.js";const s={},c=l('<h1 id="mobile-ad-hoc-network" tabindex="-1"><a class="header-anchor" href="#mobile-ad-hoc-network" aria-hidden="true">#</a> Mobile Ad Hoc Network</h1><p>Mobile Ad Hoc Network (MANET) 「移动特设网络」</p><h2 id="什么是-manet" tabindex="-1"><a class="header-anchor" href="#什么是-manet" aria-hidden="true">#</a> 什么是 MANET</h2><ul><li>基于基础设施的无线网络 <ul><li>拥有对有线骨干网的基础设施支持 <ul><li>Base stations (BS) are the bridges</li><li>A mobile host will communicate with the nearest BS</li><li>E.g., Cellular Networks / WLANs</li></ul></li><li>可靠，但设置成本高，设置时间长</li></ul></li><li>无基础设施的无线网络 <ul><li><strong>移动广告网络（MANET）是由一群没有任何BS的移动设备组成。</strong></li><li>移动设备支持多跳通信</li><li>高度合作，每个移动设备不仅是一个发射器/接收器，也是一个路由器</li><li>A msg from a source to a destination may need the help of intermediate devices for relaying this msg</li></ul></li></ul><h2 id="manet-应用程序" tabindex="-1"><a class="header-anchor" href="#manet-应用程序" aria-hidden="true">#</a> MANET 应用程序</h2><ul><li>自动化战场</li><li>特设会议「Ad hoc meetings」</li><li>Vehicle ad hoc networks</li><li>自动化的战场</li><li>无线传感器网络</li></ul><h2 id="manet-特性" tabindex="-1"><a class="header-anchor" href="#manet-特性" aria-hidden="true">#</a> MANET 特性</h2><ul><li>No centralized entity</li><li>动态网络拓扑结构「Dynamic network topology」 <ul><li>每个节点都可以是移动的</li><li>链接的形成和断裂与流动性有关</li><li>网络拓扑结构变化频繁且不可预测</li><li>缺乏对称的链接--可能是单向的链接</li></ul></li><li>不太可靠</li><li>能量受限的操作</li></ul><h2 id="manets中的路由" tabindex="-1"><a class="header-anchor" href="#manets中的路由" aria-hidden="true">#</a> MANETs中的路由</h2><h3 id="路由问题" tabindex="-1"><a class="header-anchor" href="#路由问题" aria-hidden="true">#</a> 路由问题</h3><ul><li>路线发现：如何找到一条从源头S到目的地D的合适路径？</li><li>数据包转发：如何将一个数据包从S处送到D处？</li><li>路线维护：如何维护路径？</li></ul><img src="https://pic.hanjiaming.com.cn/2022/10/16/9b1b396223d91.png" alt="1665914109510.png" style="zoom:25%;"><p>MANETs中的路由是具有挑战性的。</p><ul><li>MANETs 中的路由需要多跳通信 <ul><li>数据从源头到目的地要经过多跳。</li><li>节点发送和接收自己的数据包，同时也为其他节点转发数据包。（而传统有线网络中的大多数节点都不对数据包进行路由。）</li></ul></li><li>MANET 中的路由必须同时考虑第 2 层和第 3 层信息（连接性和干扰）。（而传统协议只依赖第三层信息）</li><li>由于移动节点，拓扑在 MANE T 中是动态的。 <ul><li>在传统网络中，拓扑结构是相对静态的。</li><li>当节点快速移动时，拓扑结构可能迅速变化。</li></ul></li><li>在 MANET 中定期更新路由表会消耗能量和带宽，但在没有数据发送的情况下可能毫无用处。</li></ul><h3 id="requirements" tabindex="-1"><a class="header-anchor" href="#requirements" aria-hidden="true">#</a> Requirements</h3><p>路线计算应该是分布式和本地化的</p><ul><li>参与路由计算和状态传播的节点应尽可能少。</li><li>使用短控制 msgs 来减少 msg 开销</li><li>路线应该是无环的</li><li>当主路由变得陈旧时，备份路由（多条不相连的路由）应该是可用的。</li></ul><h3 id="evaluation-metrics" tabindex="-1"><a class="header-anchor" href="#evaluation-metrics" aria-hidden="true">#</a> Evaluation metrics</h3><ul><li>端到端的数据吞吐量和延迟</li><li>路线获取时间</li><li>无序交货百分比</li><li>效率 <ul><li>Message overhead</li><li>Energy efficiency</li></ul></li></ul><h2 id="manet的路由协议" tabindex="-1"><a class="header-anchor" href="#manet的路由协议" aria-hidden="true">#</a> MANET的路由协议</h2><h3 id="主动与反应式" tabindex="-1"><a class="header-anchor" href="#主动与反应式" aria-hidden="true">#</a> 主动与反应式</h3><img src="https://pic.hanjiaming.com.cn/2022/10/16/9075ad89b0dd2.png" alt="1665915614115.png" style="zoom:33%;"><ul><li>Proactive Protocols「主动协议」 <ul><li>表格驱动--持续维护一致的、最新的路线</li><li>当网络拓扑结构发生变化时：更新的信息将在整个网络中传播</li><li>大量的路由信息可能永远不会被使用。</li><li>低延迟 - 需要时可立即准备好路由信息</li><li>传统的链路状态和距离矢量路由协议</li><li>DSDV</li></ul></li><li>Reactive Protocols「反应式协议」 <ul><li>按需服务--只在需要时维护路线</li><li>路线发现通常是由源头发起的</li><li>由于路由发现而产生的长延时，可能不适合实时通信</li><li>Flooding, AODV, DSR</li></ul></li></ul><h3 id="trade-off" tabindex="-1"><a class="header-anchor" href="#trade-off" aria-hidden="true">#</a> Trade-Off</h3><p>路由发现的延迟</p><ul><li>主动协议具有较低的延迟，因为路由在任何时候都被维护。</li><li>反应式协议有较高的延迟，因为只有当S试图向D发送时，才会发现从S到D的路由。</li></ul><p>路由发现/维护的开销</p><ul><li>由于持续的路由更新，积极主动的协议可能有更高的开销</li><li>反应式协议可能有较低的开销，因为只有在需要时才确定路由。</li></ul>',28),h={id:"flooding",tabindex:"-1"},u=i("a",{class:"header-anchor",href:"#flooding","aria-hidden":"true"},"#",-1),g=l('<p>发送方S希望将数据包P发送给接收方D</p><ul><li>发送方S向其所有邻居广播Package</li><li>每个邻居都收到Package <ul><li>如果第一次收到Package，它将Package转发给它的邻居们</li><li>如果P是重复的，它将不会再次转发Package</li></ul></li><li>如果接收器D可以从S到达，那么Package 可以到达D</li><li>D不再转发 Package 了</li><li>序列号用于避免同一数据包被多次转发的可能性。</li></ul><p>Flooding can be used to</p><ul><li>直接发送数据包</li><li>发送控制数据包以找到一个路径，然后该路径可用于发送数据包。</li></ul><h4 id="advantages" tabindex="-1"><a class="header-anchor" href="#advantages" aria-hidden="true">#</a> Advantages</h4><ul><li>简洁性</li><li>当信息传输频率低时，效率高</li><li>显式路由发现/维护的开销相对较高：适用于例如，节点不经常传送小数据包，而在连续的数据包传送之间发生许多拓扑结构的变化</li><li>数据传输的高可靠性：数据包可能通过多条路径传递到目的地</li></ul><h4 id="disadvantages" tabindex="-1"><a class="header-anchor" href="#disadvantages" aria-hidden="true">#</a> Disadvantages</h4><ul><li>重复的数据包造成的开销非常大 <ul><li>数据包可能被传送到太多不需要接收它们的节点（在最坏的情况下，从发送方到达的所有节点都可能收到数据包）</li><li>节点可能会收到同一数据包的太多冗余副本</li></ul></li><li>争论问题：当邻居试图重传数据包时，他们很可能会相互争夺媒介。</li><li>碰撞问题：重传有可能在同一时间开始并相互碰撞</li></ul><h4 id="flooding-problem" tabindex="-1"><a class="header-anchor" href="#flooding-problem" aria-hidden="true">#</a> Flooding Problem</h4><p>洪水可能导致广播风暴问题：在最坏的情况下，一个数据包的传输可能会引发巨大的数据包在整个网络中传播，这可能会导致高数据包冗余、高节点争用和高数据包碰撞，最终导致整个网络功能的崩溃。</p><p>如何解决这个问题？解决办法是，减少节点的数量，解决方案是减少重传数据包的节点数量</p><ul><li>Probability-based scheme：一个节点将以预定的概率p<strong>重传</strong>该数据包。</li><li>Counter-based scheme：如果收到的拷贝数少于c（一个预定义的计数器），节点将<strong>重新发送</strong>数据包。否则，不要重传该数据包。（In practice, c = 3 is enough）</li><li>Distance-based scheme：一个节点可能从几个发件人那里收到相同的数据包。节点计算到每个发件人的距离。 <ul><li>如何找到距离？信号强度或GPS设备</li></ul></li><li>etc</li></ul>',12),p={id:"目的地序列距离向量-dsdv",tabindex:"-1"},m=i("a",{class:"header-anchor",href:"#目的地序列距离向量-dsdv","aria-hidden":"true"},"#",-1),f=l('<p>DSDV是基于距离矢量的路由协议</p><p>广泛应用于有线网络</p><ul><li>距离向量路由</li><li>定期与所有邻居交换路由信息：路由信息包含可到达的目的地节点和到每个目的地节点的距离。</li><li>如果有几条通往目的地的路径，它将选择最短的路径。</li></ul><h3 id="算法" tabindex="-1"><a class="header-anchor" href="#算法" aria-hidden="true">#</a> 算法</h3><ul><li>一个节点定期向其邻居广播其估计的距离。</li><li>然后每个邻居在这个距离上加一。如果这个新距离小于它当前的估计值，它就采用新的距离。</li></ul><img src="https://pic.hanjiaming.com.cn/2022/10/17/d8f0bed609ea4.png" alt="1665975028500.png" style="zoom:33%;"><h3 id="示例" tabindex="-1"><a class="header-anchor" href="#示例" aria-hidden="true">#</a> 示例</h3><figure><img src="https://pic.hanjiaming.com.cn/2022/10/17/f29b25cbc6eb5.png" alt="1665976055529.png" tabindex="0" loading="lazy"><figcaption>1665976055529.png</figcaption></figure><figure><img src="https://pic.hanjiaming.com.cn/2022/10/17/1405cf16e93b5.png" alt="1665976075800.png" tabindex="0" loading="lazy"><figcaption>1665976075800.png</figcaption></figure><figure><img src="https://pic.hanjiaming.com.cn/2022/10/17/f20ae66d9a6df.png" alt="1665976096132.png" tabindex="0" loading="lazy"><figcaption>1665976096132.png</figcaption></figure><figure><img src="https://pic.hanjiaming.com.cn/2022/10/17/2292cf2762012.png" alt="1665976106817.png" tabindex="0" loading="lazy"><figcaption>1665976106817.png</figcaption></figure><h3 id="dsdv-协议" tabindex="-1"><a class="header-anchor" href="#dsdv-协议" aria-hidden="true">#</a> DSDV 协议</h3><p>每个节点都维护一个路由表，包括</p><ul><li>目的地 Destination - 所有可能的目的地</li><li>下一个 Next - 到每个目的地的下一跳</li><li>公制 Metrx - 到每个目的地的公制</li><li>序列号 Sequence number - 源自目的地的 SN 确保</li><li>安装时间 Install Time - 条目最后被修改的时间（用于从表中删除陈旧的条目）。</li><li>稳定数据 Stable Data- 一个指向保存路由稳定程度信息的表的指针（用于抑制网络的波动）。</li></ul><img src="https://pic.hanjiaming.com.cn/2022/10/17/26638b0aae9c9.png" alt="1665976130315.png" style="zoom:33%;"><p>每个路由都被标记为目的地序列号</p><ul><li>每个节点执行周期性的路由更新，发布一个新的序列号</li><li>顺序号继续增加它的值，这表示一个路由信息的 &quot;新鲜度&quot;。 <ul><li>序列号较大的路由更新鲜</li><li><strong>如果序列号相同，则使用 metric 最小的一个。</strong></li></ul></li><li>序列号将与以该节点为目的地的路由条目相关联（所谓的目的地序列化）。</li><li>用来避免循环的序列号：解决DV路由的问题（数到无穷大，循环）。</li></ul><h3 id="dsdv-协议-路由通告" tabindex="-1"><a class="header-anchor" href="#dsdv-协议-路由通告" aria-hidden="true">#</a> DSDV 协议：路由通告</h3><p>节点向每个邻居公布自己的路由信息</p><ul><li>路由信息包括 <ul><li>Destination address</li><li>Metric: number of hops to destination</li><li>Destination sequence number</li></ul></li><li>设置目的地序列号的规则 <ul><li><strong>在每个广告中，节点增加自己的目的地序列号（只使用偶数）。</strong></li><li>如果目标节点不再可达（超时），节点将该节点的序列号增加 1（奇数序列号）并设置 metric = ∞</li></ul></li></ul><h3 id="dsdv-协议-路由选择" tabindex="-1"><a class="header-anchor" href="#dsdv-协议-路由选择" aria-hidden="true">#</a> DSDV 协议：路由选择</h3><p>更新的路由信息与自己的路由表进行比较</p><ul><li>选择具有较高目的地序列号的路由（这确保总是使用来自目的地的最新信息）。</li><li>当序列号相等时选择具有更好度量的路由</li></ul><h3 id="dsdv-协议-拓扑变化" tabindex="-1"><a class="header-anchor" href="#dsdv-协议-拓扑变化" aria-hidden="true">#</a> DSDV 协议：拓扑变化</h3><p>当发现新的路线时</p><ul><li>节点立即发送路由通告消息</li><li>新路由的路由更新信息会立即传播给邻居。</li><li>全面更新/增量更新 <ul><li>全面更新：路由通告消息包含自己表中的所有路由信息</li><li>递增式更新：路由广告信息只包括已经改变的条目</li></ul></li></ul><img src="https://pic.hanjiaming.com.cn/2022/10/17/fbfe3eac6b124.png" alt="1665989877784.png" style="zoom:33%;"><img src="https://pic.hanjiaming.com.cn/2022/10/17/c4a5ef2442338.png" alt="1665989904484.png" style="zoom:33%;"><p>远距离矢量路由协议中的断裂链接</p><ul><li>节点为断开的链接分配一个度量值∞</li><li>任何通过断裂链路的路线也被赋予一个∞的值</li><li><strong>&quot;∞&quot;路由被分配新的奇数序列号</strong>，并立即触发路由更新信息传播</li><li>如果一个节点对&quot;∞&quot;路由有一个相等/较高的序列号，并有一个有限的度量，则该节点的路由表将被更新，并立即发送一个路由更新信息。</li></ul><img src="https://pic.hanjiaming.com.cn/2022/10/17/a4352d01bbc8f.png" alt="1665991131359.png" style="zoom:33%;"><img src="https://pic.hanjiaming.com.cn/2022/10/17/dfd32c4b5654b.png" alt="1665991188497.png" style="zoom:33%;">',32),b={id:"ad-hoc-按需距离矢量-aodv",tabindex:"-1"},_=i("a",{class:"header-anchor",href:"#ad-hoc-按需距离矢量-aodv","aria-hidden":"true"},"#",-1),x=l(`<ul><li>纯粹的按需路由协议（减少数据包的开销） <ul><li>一个节点不执行路由发现或维护，直到它需要一个到另一个节点的路由，或者它作为一个中间节点提供其路由服务。</li><li>不在活动路径上的节点不维护路由信息，不参与路由表交换</li></ul></li><li>使用广播路由发现机制</li><li>Use hop-by-hop routing: 路由是基于中间节点维护的动态表项而建立的</li></ul><h3 id="aodv-protocol" tabindex="-1"><a class="header-anchor" href="#aodv-protocol" aria-hidden="true">#</a> AODV Protocol</h3><ul><li>每个节点使用HELLO消息来确定本地连接性</li><li>顺序号被分配给路由和路由表项, 以取代陈旧的缓存路由条目</li><li>以取代陈旧的缓存路由条目: 节点序列号，广播ID</li></ul><p>AODV Protocol: Path Discovery</p><p>每当节点想进行通信时，就会启动路径发现程序。节点向邻近节点广播**<u>路线请求包（RREQ）</u>**。当一个邻居节点收到RREQ。</p><ul><li>如果邻居本身就是目标，或者知道一个更近的路线，那么该节点将发送**<u>路线回复（RREP）</u>**。</li><li>否则，节点在增加 hop_cnt 后传播 RREQ，并设置一个<strong>指向接收到 RREQ 的邻居</strong>的指针（反向路径）。</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>&lt; source_addr, source_sequence_# , 
broadcast_id, 
dest_addr, dest_sequence_#, 
hop_cnt &gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>RREQ由&lt;source_addr , broadcast_id&gt;唯一标识</li><li>broadcast_id随每个RREQ递增</li><li>Dest_sequence_# 表示到目的地的路由的新鲜度</li><li>source_sequence_# 表示反向路由到源的新鲜度</li></ul><h3 id="aodv-协议-路径发现" tabindex="-1"><a class="header-anchor" href="#aodv-协议-路径发现" aria-hidden="true">#</a> AODV 协议：路径发现</h3><p>当一个邻居节点收到RREQ</p><ul><li>如果邻居本身就是目标，或者知道一个更近的路线，那么该节点将发送路线回复（RREP）。</li><li>否则，节点在增加 hop_cnt 后传播 RREQ，并设置一个<strong>指向接收到 RREQ 的邻居</strong>的指针（反向路径）。</li></ul><h3 id="反向路径设置" tabindex="-1"><a class="header-anchor" href="#反向路径设置" aria-hidden="true">#</a> 反向路径设置</h3><p>当一个节点转发一个RREQ时，它在其路由表中为来源建立一个反向路由条目。这个反向路由条目包含</p><ul><li>source node ID</li><li>source sequence number</li><li>used to maintain freshness about reverse route to source 「用来保持对源头反向路线的新鲜度」</li><li>number of hops</li><li>neighbor ID 「neighbor ID」</li></ul><h2 id="动态源路由-dsr" tabindex="-1"><a class="header-anchor" href="#动态源路由-dsr" aria-hidden="true">#</a> 动态源路由（DSR）</h2><h3 id="源路由与分布式路由" tabindex="-1"><a class="header-anchor" href="#源路由与分布式路由" aria-hidden="true">#</a> 源路由与分布式路由</h3><ul><li>Source routing： Source决定了到目的地的整条路径</li><li>Distributed routing <ul><li>每个节点自己决定其下一跳。</li><li>到目的地的路径是由所有节点的下一跳节点逐步确定的</li></ul></li></ul><figure><img src="https://pic.hanjiaming.com.cn/2022/12/11/3041f778736d3.png" alt="CleanShot 2022-12-11 at 19.25.58@2x.png" tabindex="0" loading="lazy"><figcaption>CleanShot 2022-12-11 at 19.25.58@2x.png</figcaption></figure><ul><li>一个反应式（按需）、无循环的协议</li><li>没有定期的路由广告消息 (从而减少网络带宽的开销) <ul><li>只有在需要向某一目的地发送数据包的路径，而目前没有路径可用时，才会触发路由发现「Route discovery」</li><li>只有在使用路径时才需要进行路径维护「Route maintenance」，它确保了路径可以连续使用。</li></ul></li></ul><p>每个节点都维护一个路由缓存，储存它所学到的路由。</p><ul><li>如果没有从路由缓存中找到一个路由，源头会尝试使用路由发现来发现一个路由</li><li>航线维护监控使用中的航线的正确运行。</li></ul><h3 id="dsr-协议-路由回复" tabindex="-1"><a class="header-anchor" href="#dsr-协议-路由回复" aria-hidden="true">#</a> DSR 协议：路由回复</h3>`,22);function v(D,R){const e=r("Badge");return d(),o("div",null,[c,i("h2",h,[u,a(" Flooding "),n(e,{text:"算法设计",type:"info"})]),g,i("h2",p,[m,a(" 目的地序列距离向量(DSDV) "),n(e,{text:"算法设计",type:"info"})]),f,i("h2",b,[_,a(" Ad hoc 按需距离矢量 (AODV) "),n(e,{text:"算法设计",type:"info"})]),x])}const y=t(s,[["render",v],["__file","Mobile-Ad-Hoc-Networks.html.vue"]]);export{y as default};
