import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as i,c as n,e as a}from"./app-7ddc3302.js";const t={},r=a('<h1 id="google-kubernetes" tabindex="-1"><a class="header-anchor" href="#google-kubernetes" aria-hidden="true">#</a> Google Kubernetes</h1><figure><img src="https://pic.hanjiaming.com.cn/2024/05/09/0d28dc181f658.png" alt="1715244384263.png" tabindex="0" loading="lazy"><figcaption>1715244384263.png</figcaption></figure><p>Container Management and Orchestration Tools -&gt; How to build and manage a container cluster?</p><p>Google Kubernetes (K8s)</p><ul><li>Kubernetes Architecture</li><li>Kubernetes Pods,Namespace Quota</li><li>Kubernetes Volume</li></ul><p>Kubernetes 又称 K8s，是一个开源系统，用于自动化部署、扩展和管理容器化应用程序。</p><ul><li>它将组成应用程序的容器分组为逻辑单元，以便于管理和发现</li><li>Kubernetes 建立在 Google 15 年运行生产工作负载的经验之上，并结合了社区的最佳理念和实践。</li></ul><p>Kubernetes 是一个跨节点集群管理容器化应用程序的系统。Kubernetes 可以协调 Docker 容器、Rkt 容器等！</p><p>Container orchestration is all about managing the <u>lifecycles of containers</u>, especially in large, dynamic environments (e.g.,a big cluster). Existing tools:</p><ul><li>Kubernetes (2015:Google open sourced,short for &quot;K8S&quot;)</li><li>Amazon&#39;s Elastic Container Service (ECS)</li><li>Amazon Elastic Kubernetes Service (EKS)</li><li>Azure&#39;s Container Service (AKS)</li></ul><h2 id="caas" tabindex="-1"><a class="header-anchor" href="#caas" aria-hidden="true">#</a> CaaS</h2><ul><li>CaaS 通常是指一个完整的容器环境，包括协调工具、镜像目录、集群管理软件以及一套开发者工具和 APls。</li><li>Container Orchestrators <ul><li>自动化容器的生命周期；</li><li>在虚拟机上创建服务、调度任务和 pod。</li></ul></li></ul><figure><img src="https://pic.hanjiaming.com.cn/2024/05/05/2143b911a3fe7.png" alt="1714842567174.png" tabindex="0" loading="lazy"><figcaption>1714842567174.png</figcaption></figure><div class="hint-container note"><p class="hint-container-title">Container Orchestration (Case: Deployment)</p><figure><img src="https://pic.hanjiaming.com.cn/2024/05/05/57ffed717a98b.png" alt="1714842657543.png" tabindex="0" loading="lazy"><figcaption>1714842657543.png</figcaption></figure></div><h2 id="task-done-by-orchestrator" tabindex="-1"><a class="header-anchor" href="#task-done-by-orchestrator" aria-hidden="true">#</a> Task done by Orchestrator</h2><ul><li>Provisioning「调配」 and deployment of containers</li><li>Redundancy and availability of containers</li><li>扩展或移除容器，以便在主机基础设施上均匀「evenly」分布应用程序负载</li><li>在主机资源短缺或主机死亡的情况下，将容器从一台主机转移到另一台主机</li><li>Allocation of resources between containers</li><li>Load balancing between containers</li><li>Health monitoring of containers and hosts</li><li>Configuration of an application in relation to the containers running it</li></ul><p>通常在 YAML（如 deploy.yaml）或 JSON 文件中描述应用程序的配置。</p><h2 id="architecture" tabindex="-1"><a class="header-anchor" href="#architecture" aria-hidden="true">#</a> Architecture</h2><p>master-slave architecture</p><figure><img src="https://pic.hanjiaming.com.cn/2024/05/05/cc2bc92db8305.png" alt="1714843096032.png" tabindex="0" loading="lazy"><figcaption>1714843096032.png</figcaption></figure><p>容器位于 Pod 内。</p><h2 id="components" tabindex="-1"><a class="header-anchor" href="#components" aria-hidden="true">#</a> Components</h2><ul><li><strong>Kubernetes Master</strong>: <strong>runs on a single node</strong> in your cluster <ul><li>类似于 Yarn 的 ResourceManager</li></ul></li><li><strong>Kubelet</strong>: the primary &quot;node agent&quot;that runs <strong>on each node</strong><ul><li>类似于 Yarn 的 NodeManager</li><li>creating pods and make sure they are all running</li><li>Kubelet是在Kubernetes集群中每个节点上运行的主要“节点代理”</li><li>它负责维护和管理该节点上的Pods（Pod是Kubernetes中的最小部署单元）。</li><li>Kubelet接收一组由各种机制（主要是通过apiserver）提供的PodSpecs，然后确保这些PodSpecs中描述的容器正在运行并且是健康的。它还负责报告节点的状态以及运行中的Pod的状态。</li></ul></li><li><strong>Kube-proxy</strong>: a network proxy and load balancer (packet forwarding) that runs in each node.</li><li><strong>etcd</strong>: a distributed, <u>key-value data store</u> for the master node to store the configuration data of the cluster.</li><li><strong>cAdvisor</strong>: provides a metric monitoring capability</li></ul><figure><img src="https://pic.hanjiaming.com.cn/2024/05/05/8790cef7df266.png" alt="1714843708757.png" tabindex="0" loading="lazy"><figcaption>1714843708757.png</figcaption></figure><h2 id="workflow" tabindex="-1"><a class="header-anchor" href="#workflow" aria-hidden="true">#</a> Workflow</h2><figure><img src="https://pic.hanjiaming.com.cn/2024/05/05/ed4976571ab21.png" alt="1714843883291.png" tabindex="0" loading="lazy"><figcaption>1714843883291.png</figcaption></figure><ol><li>用户通过 kubectl 命令行工具向 Kubernetes 发送命令。kubectl 会将用户的命令翻译成一个声明式的 Deployment 对象。Deployment 是 Kubernetes 的一个高级 API，它支持滚动更新。</li><li>kubectl 将 Deployment 对象发送到运行在集群中的 Kubernetes API 服务器（kube-apiserver）。</li><li>kube-apiserver 将 Deployment 对象存储在 etcd 中。etcd 是一个运行在集群中的分布式键值存储系统，kube-apiserver 会向 kubectl 响应。</li><li>Kubernetes 控制器管理器（kube-controller-manager）异步地监听 Deployment 事件，从 Deployment 创建一个 ReplicaSet，并将其发送到 kube-apiserver。ReplicaSet 是 Deployment 的一个版本。在滚动更新过程中，会创建一个新的 ReplicaSet，并逐步扩展到期望的副本数量，同时旧的 ReplicaSet 会逐步缩减到零。</li><li>kube-apiserver 将 ReplicaSet 保存到 etcd 中。</li><li>kube-controller-manager 从 ReplicaSet 创建两个（或更多，如果我们扩展）Pods，并将它们发送到 kube-apiserver。Pod 是 Kubernetes 的基本单位，它代表一个或多个共享 Linux cgroup 和命名空间的容器。</li><li>kube-apiserver 将 Pods 保存到 etcd 中。</li><li>Kubernetes 调度器（kube-scheduler）异步地监听 Pod 事件，更新每个 Pod 以将其分配给一个 Node，并将它们发送回 kube-apiserver。</li><li>kube-apiserver 将 Pods 保存到 etcd 中。</li><li>最后，运行在分配的 Node 上的 kubelet（始终在监听）实际启动容器。</li></ol><figure><img src="https://pic.hanjiaming.com.cn/2024/05/05/f5f41c1fe110c.png" alt="1714843828820.png" tabindex="0" loading="lazy"><figcaption>1714843828820.png</figcaption></figure><ol><li><p>客户端发送一个部署请求到 API Server。这个请求通常由 <code>kubectl create -f deployment.yml</code> 命令发送。</p></li><li><p>API Server 将部署信息持久化到 etcd 数据库中。etcd 返回 200 状态码给 API Server，然后 API Server 返回 200 状态码给客户端。这个时候，部署的创建工作并没有完成，还有许多后台的异步操作需要进行。</p></li><li><p>Controller Manager 对 API Server 设置了监听 (watch)，当它看到有新的部署创建时，会将这个部署的信息填充到 SharedCache 中。</p></li><li><p>Deployment Controller 看到新的部署后，会从队列中取出它，然后创建一个 ReplicaSet，并将 ReplicaSet 对象持久化到 API Server 和 etcd 中。</p></li><li><p>对 ReplicaSet 重复步骤 3。</p></li><li><p>ReplicaSet Controller 看到新的 ReplicaSet 后，会从队列中取出它，然后创建指定数量的 Pods，并将 Pods 对象持久化到 API Server 和 etcd 中。</p></li><li><p>对 Pods 重复步骤 3，但这次是由 Scheduler 来执行。</p></li><li><p>Scheduler 看到未调度的 Pods 后，会执行其业务逻辑，将 Pods 的 Spec 中的 nodeName 字段填充为可调度的 Node 的名称，并将调度后的 Pods 对象持久化到 API Server 和 etcd 中。</p></li><li><p>对 Pods 重复步骤 3，但这次是由 Kubelet 来执行。</p></li><li><p>Kubelet（在被调度的节点上）看到它应该在其机器上运行一个 Pod，然后与容器运行时（如 Docker）进行交互，使得 Pod 能在其机器上运行。</p></li></ol><div class="hint-container info"><p class="hint-container-title">Kubernetes Container Runtime</p><p>Docker 并非唯一选择</p><p>The container runtime is responsible for</p><ul><li>pulling the container image from a registry</li><li>unpacking the container images</li><li>running the application.</li></ul><p>Kubernetes 支持的容器运行时：Docker、containerd、cri-o、Frakti、rktlet 和 Kubernetes CRI（容器运行时接口）的任何实现。</p><p>容器运行时接口（CRI） - 一个插件接口，使 kubelet 能够使用各种容器运行时</p></div><h2 id="kubernetes-pod" tabindex="-1"><a class="header-anchor" href="#kubernetes-pod" aria-hidden="true">#</a> Kubernetes Pod</h2><p>A pod consists of one or more containers</p><ul><li>Pod 是 Kubernetes 中最小的<u>可部署单元</u></li><li>同一 pod 中的容器位于同一位置，并调度在同一台机器上。</li><li>Network: Each Pod is assigned a unique IP address <ul><li>Pod 中的所有容器共享相同的 IP 地址和端口空间。</li><li>存储：Pod 中的应用程序可访问共享卷（ = 本地磁盘空间或网络磁盘）。</li></ul></li></ul><div class="hint-container tip"><p class="hint-container-title">提示</p><p>In terms of Docker concept, a Pod is just a group of Docker containers with <strong>shared namespaces</strong> and <strong>shared filesystem volumes</strong>.</p></div><h2 id="kubernetes-scheduler" tabindex="-1"><a class="header-anchor" href="#kubernetes-scheduler" aria-hidden="true">#</a> Kubernetes Scheduler</h2><p>Scheduler is <strong>a component in a master node</strong>,which is responsible for deciding which worker node should run a given pod.</p><p>2-step operation:</p><ol><li>Filtering (e.g.,enough resource?)</li><li>Scoring (pick the one with the highest ranking)</li></ol><p><strong>Scheduler spreads pods across available nodes 「调度程序将 Pod 分散到可用节点上」</strong></p><figure><img src="https://pic.hanjiaming.com.cn/2024/05/06/b282d167428bd.png" alt="1714986451624.png" tabindex="0" loading="lazy"><figcaption>1714986451624.png</figcaption></figure><h2 id="kubernetes-cadvisor" tabindex="-1"><a class="header-anchor" href="#kubernetes-cadvisor" aria-hidden="true">#</a> Kubernetes cAdvisor</h2><ul><li>cAdvisor （容器顾问）是一种开源容器资源使用情况收集器，作为 Kubelet 二进制文件的一部分。</li><li>cAdvisor auto-discovers all containers in the given node and collects CPU,memory,filesystem,and network usage for those containers.</li><li>Kubelet 可直接从 cAdvisor 提取容器资源使用指标「metrics」，并根据这些指标做出决策。</li></ul><h2 id="kubernetes-dashboard" tabindex="-1"><a class="header-anchor" href="#kubernetes-dashboard" aria-hidden="true">#</a> Kubernetes Dashboard</h2><p>用于观察 Kubernetes 中容器的默认基于 Web 的用户界面。</p><ul><li>在 pod 中部署应用程序</li><li>pod 中运行的应用程序概览。</li><li>对 Pod 中正在运行的应用程序进行故障排除「Troubleshoot」。</li><li>允许您更改集群所需的资源量。</li><li>监控每个 Kubernetes pod 的 RAM 和 CPU 利用率</li></ul><figure><img src="https://pic.hanjiaming.com.cn/2024/05/06/bdd76d2563131.png" alt="1714986949911.png" tabindex="0" loading="lazy"><figcaption>1714986949911.png</figcaption></figure><details class="hint-container details"><summary>Check Current Resource Usage</summary><p>Use “kubectl top” command check current resource usage</p><figure><img src="https://pic.hanjiaming.com.cn/2024/05/06/9f2dae2ac98eb.png" alt="1714987161472.png" tabindex="0" loading="lazy"><figcaption>1714987161472.png</figcaption></figure><p>Docker Stats: Monitor CPU/Memory Usage</p><figure><img src="https://pic.hanjiaming.com.cn/2024/05/06/c5d587434fd71.png" alt="1714987180608.png" tabindex="0" loading="lazy"><figcaption>1714987180608.png</figcaption></figure><p>CPU/Memory Usage during Spark TeraSort</p><figure><img src="https://pic.hanjiaming.com.cn/2024/05/06/f712a33146cfb.png" alt="1714987222620.png" tabindex="0" loading="lazy"><figcaption>1714987222620.png</figcaption></figure></details><h2 id="volumes" tabindex="-1"><a class="header-anchor" href="#volumes" aria-hidden="true">#</a> Volumes</h2><ul><li>On-disk files in a container are ephemeral「短暂的」.</li><li>当容器崩溃时，kubelet 会重新启动容器，但处于<strong>干净状态（之前的所有更改都会丢失）。</strong></li><li>为了获得独立于容器的更一致的存储，可以使用卷「Volume」。</li></ul><p>A Pod uses a Volume for storage</p><ul><li>Volumes can be used by all containers in pod, but they <strong>must be mounted</strong> in each container that needs to access them first.</li><li>Each Container in the Pod&#39;s configuration must independently specify「指定」 <u>where to mount each volume</u></li></ul><p>Two basic types of Volumes:</p><ul><li>Ephemeral「临时的」 volume：具有 pod 的生命周期。当 pod 不再存在时，Kubernetes 会销毁临时卷。例如，<strong>emptyDir</strong>、configMap、secret 等。</li><li>Persistent volume: 在 Pod 的生命周期之外存在（即使 Pod 崩溃或被删除也能生存）。例如，<strong>hostPath</strong>、perpetitiveVolumeClaim、awsElasticBlockStore、azureDisk、gcePersistentDisk</li></ul><p>对于给定 pod 中的任何卷，数据都会**在容器（而非 Pod）**重启时保留。</p><p>Type of Kubernetes</p><ul><li>Node-local <ul><li>emptyDir：当 pod 被分配给一个节点时创建的初始空卷；即使 pod 中的容器终止并重新启动，该卷也会在 Pod 的生命周期内持续存在。</li><li>hostPath：将主机节点文件系统中的文件或目录挂载到 pod 中</li></ul></li><li>nsf：将现有的 NFS（网络文件系统）挂载到 pod 中。</li><li>permanentVolumeClaim：将 PersistentVolume 挂载到 pod 中，并在 pod 的生命周期结束后持续存在。</li><li>分布式文件系统：CephFS、rbd、Glusterfs</li><li>特定于云提供商的 awsElasticBlockStore（AWS）、gcePersistentDisk（Google Cloud）和 azureDiskVolume（Azure）。</li></ul><h3 id="emptydir" tabindex="-1"><a class="header-anchor" href="#emptydir" aria-hidden="true">#</a> emptyDir</h3><p>“empty” at Pod startup</p><figure><img src="https://pic.hanjiaming.com.cn/2024/05/07/3b051f5a0f1e0.png" alt="1715066263598.png" tabindex="0" loading="lazy"><figcaption>1715066263598.png</figcaption></figure><h3 id="hostpath" tabindex="-1"><a class="header-anchor" href="#hostpath" aria-hidden="true">#</a> HostPath</h3><p>a pre-existing file or directory on the host machine</p><figure><img src="https://pic.hanjiaming.com.cn/2024/05/07/b5aa0d58adf15.png" alt="1715066298833.png" tabindex="0" loading="lazy"><figcaption>1715066298833.png</figcaption></figure>',62),o=[r];function l(s,c){return i(),n("div",null,o)}const u=e(t,[["render",l],["__file","kubernetes.html.vue"]]);export{u as default};
