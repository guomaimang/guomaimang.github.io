import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as n,c as i,e as a}from"./app-da918afa.js";const l={},s=a(`<h1 id="non-fungible-tokens" tabindex="-1"><a class="header-anchor" href="#non-fungible-tokens" aria-hidden="true">#</a> Non-Fungible Tokens</h1><h2 id="nft" tabindex="-1"><a class="header-anchor" href="#nft" aria-hidden="true">#</a> NFT</h2><p>Non-Fungible Tokens (NFT)</p><p>可替代性：各个单位能够相互替代</p><div class="hint-container tip"><p class="hint-container-title">代币的概念</p><p>代币是区块链上的数字资产，可以代表各种价值，如货币、资产、权益等。</p><p>代币可以分为可替代代币（Fungible Tokens）和不可替代代币（Non-Fungible Tokens, NFTs），它们在性质和用途上有显著差异。</p></div><p>可替代代币（如ERC20代币）是指每个代币都是相同的，并且可以分割成更小的单位。这意味着一个代币可以与另一个代币互换，没有区别。</p><ul><li>默认情况下，可替代代币使用18个小数位。 <ul><li>这意味着一个完整的代币可以分割成10的18次方个更小的单位。</li><li>这种设计允许非常精细的交易。</li></ul></li><li>不可替代代币（NFT，如ERC721代币）是指每个代币都是独一无二的，并且通过一个唯一的tokenID进行标识。 <ul><li>这使得NFT能够代表独特的资产，如艺术品、收藏品等。</li></ul></li></ul><p>FT可以代表各种独特的资产，如收藏品、投票权、统一资源标识符（URIs）等。</p><ul><li>URIs可以是HTTP链接或IPFS链接，与tokenID相关联。</li><li>OpenSea是一个流行的NFT交易平台，EIP-721是定义NFT标准的提案。</li></ul><p><strong>NFT是对可替代代币的扩展，增加了唯一性和不可分割性，使其能够代表独特的资产。</strong></p><ul><li><strong>NFT是不可分割的，这意味着一个NFT不能被分割成更小的单位。</strong></li><li><strong>每个NFT都是一个完整的、独特的实体。</strong></li></ul><p><strong>Multi-tokens (ERC1155):</strong> 多代币标准（ERC1155）允许在一个智能合约中包含不同类型的代币，包括可替代代币和不可替代代币。</p><ul><li>一个ERC1155合约可以同时包含多种可替代代币和不可替代代币，使得开发者可以在一个合约中管理多种不同类型的资产。</li><li>这种设计提高了代币管理的灵活性和效率。</li></ul><div class="hint-container info"><p class="hint-container-title">ERC标准</p><p>ERC（Ethereum Request for Comments）是以太坊改进提案的缩写，定义了以太坊生态系统中的各种规范和标准。</p><p>ERC20和ERC721是两种常见的ERC标准，分别用于定义可替代代币和不可替代代币。</p></div><details class="hint-container details"><summary>将数字艺术作品转化为NFT</summary><p>假设你是一位数字艺术家，想要将你的数字艺术作品转化为NFT，并在OpenSea平台上进行销售。</p><p>你需要将你的艺术作品铸造成NFT，</p><ul><li>这意味着你需要使用ERC721标准创建一个唯一的代币，每个代币代表一件独特的艺术作品。</li><li>然后，你需要将这些NFT上传到OpenSea平台进行销售。</li></ul><p>NFT的唯一性和不可分割性使其非常适合代表独特的艺术作品。通过将你的艺术作品铸造成NFT，你可以确保每个作品都是独一无二的，并且可以在区块链上进行追踪和交易。</p><ol><li><strong>创建智能合约</strong>：编写一个符合ERC721标准的智能合约，定义你的NFT。</li><li><strong>铸造NFT</strong>：使用智能合约铸造NFT，每个NFT代表一件艺术作品。</li><li><strong>上传到OpenSea</strong>：将铸造的NFT上传到OpenSea平台，设置销售价格和其他相关信息。</li><li><strong>销售和交易</strong>：在OpenSea平台上进行销售和交易，买家可以通过区块链购买你的NFT。</li></ol></details><h2 id="erc20" tabindex="-1"><a class="header-anchor" href="#erc20" aria-hidden="true">#</a> ERC20</h2><h3 id="在以太坊上启用可互换代币" tabindex="-1"><a class="header-anchor" href="#在以太坊上启用可互换代币" aria-hidden="true">#</a> 在以太坊上启用可互换代币</h3><p>可替代代币（如ERC20代币）是指每个代币在价值和功能上都是完全相同的，可以互换。</p><p><strong>例如，一个ERC20代币和另一个ERC20代币在同一合约中具有相同的价值。</strong></p><ul><li>从一个账户向其他账户转移代币: ERC20标准定义了一种方法，使得用户可以将代币从一个账户转移到另一个账户。这是通过智能合约中的<code>transfer</code>函数实现的</li><li>获取账户代币余额: ERC20标准提供了一个<code>balanceOf</code>函数，允许用户查询特定地址的代币余额</li><li>ERC20标准中的<code>totalSupply</code>函数返回代币的总供应量。这表示了该代币在整个区块链网络中的总发行量。</li><li>ERC20标准中的<code>approve</code>函数允许代币持有者授权第三方账户在其名下花费一定数量的代币。这通常用于去中心化交易所或其他需要代币授权的应用。 <ul><li>在去中心化交易所Uniswap中，用户需要首先使用<code>approve</code>函数授权Uniswap智能合约可以代表用户转移一定数量的代币，以便进行代币交换。</li><li>在完成授权后，Uniswap会调用<code>transferFrom</code>函数，从用户账户中转移代币到目标账户。这是代币交换过程的一部分。</li></ul></li></ul><details class="hint-container details"><summary>Example</summary><p>假设Alice想要在Uniswap上将她的ERC20代币（例如DAI）交换成另一种ERC20代币（例如USDC）。</p><p>Alice需要首先批准Uniswap智能合约可以代表她转移一定数量的DAI代币，然后Uniswap智能合约会执行代币交换，将DAI转换成USDC。</p><p>这个过程涉及ERC20标准中的<code>approve</code>和<code>transferFrom</code>函数，Alice需要先使用<code>approve</code>函数授权Uniswap智能合约，然后Uniswap智能合约会调用<code>transferFrom</code>函数完成代币转移。</p><ol><li>Alice调用DAI合约的 <code>approve</code> 函数，授权Uniswap智能合约可以转移她的100 DAI代币。<div class="language-solidity line-numbers-mode" data-ext="solidity"><pre class="language-solidity"><code>dai<span class="token punctuation">.</span><span class="token function">approve</span><span class="token punctuation">(</span>uniswapContractAddress<span class="token punctuation">,</span> <span class="token number">100</span> <span class="token operator">*</span> <span class="token number">10</span><span class="token operator">**</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li>Uniswap智能合约接收到授权后，Alice可以发起代币交换请求。</li><li>Uniswap智能合约调用<code>transferFrom</code>函数，从Alice的账户中转移100 DAI到合约中，并根据当前汇率将等值的USDC转移到Alice的账户中。</li></ol></details><h3 id="create-your-erc20" tabindex="-1"><a class="header-anchor" href="#create-your-erc20" aria-hidden="true">#</a> Create Your ERC20</h3><p>利用现有的合约代码可以大大减少开发时间和出错的几率。OpenZeppelin提供了经过社区验证的安全合约实现，非常适合用来构建自己的ERC20代币。</p><p>在创建自己的ERC20代币时，你需要重写构造函数（constructor）。构造函数是在合约部署时执行的特殊函数，用于初始化合约的状态。</p><details class="hint-container details"><summary>Example</summary><p>假设你想创建一个名为“StudentToken”的ERC20代币，每个代币有18位小数，并且在合约部署时向自己铸造1000个代币。</p><p>为了实现这个目标，</p><ul><li>你需要定义一个合约，继承ERC20标准，</li><li>并在构造函数中初始化代币的名称、符号和小数位数。</li><li>同时，你需要在合约部署时铸造1000个代币给自己。</li></ul><p>ERC20标准提供了一组通用的方法和事件，使代币能够在不同的dApps之间互操作。<strong>通过继承ERC20合约并重写构造函数，你可以轻松创建符合ERC20标准的代币。</strong></p><ol><li>创建一个新的Solidity文件，命名为<code>StudentToken.sol</code>。</li><li>导入OpenZeppelin的ERC20合约。</li><li>定义一个名为<code>StudentToken</code>的合约，并继承ERC20合约。</li><li>在构造函数中初始化代币的名称、符号和小数位数。</li><li>使用<code>_mint</code>函数在合约部署时向自己铸造1000个代币。</li></ol></details><h3 id="extend-to-defi" tabindex="-1"><a class="header-anchor" href="#extend-to-defi" aria-hidden="true">#</a> Extend to DeFi</h3><p>ERC20代币可以部署在公共区块链上。</p><ul><li>Permissionless：意味着任何人都可以与合约进行交互，不需要得到任何特定实体的授权或许可。</li><li>Transparency「透明度」：例如，Tether在Etherscan上。Tether是一种ERC20代币，其智能合约的字节码和源代码可以在Etherscan上查看。</li><li>Composable「可组合的」：智能合约可以相互组合，形成更复杂的金融产品和服务。 <ul><li>例如，一个交换ERC20代币的合约。这样的合约可以自动执行代币交换操作。</li><li>Uniswap和其他复杂合约 -&gt; 去中心化交易所/去中心化金融。Uniswap是一个去中心化交易所，允许用户在没有中介的情况下进行代币交换。</li></ul></li></ul><h3 id="swap-between-2-erc20-tokens" tabindex="-1"><a class="header-anchor" href="#swap-between-2-erc20-tokens" aria-hidden="true">#</a> Swap between 2 ERC20 tokens</h3><ul><li>Inside contract TokenSwap</li><li>在智能合约 TokenSwap 内部。</li><li></li></ul>`,30),t=[s];function o(r,p){return n(),i("div",null,t)}const u=e(l,[["render",o],["__file","nft.html.vue"]]);export{u as default};
