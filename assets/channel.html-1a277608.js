import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{o as l,c as e,e as a}from"./app-248d1dbd.js";const n={},t=a('<h1 id="payment-channel" tabindex="-1"><a class="header-anchor" href="#payment-channel" aria-hidden="true">#</a> Payment Channel</h1><h2 id="a-division-of-blockchain-layers" tabindex="-1"><a class="header-anchor" href="#a-division-of-blockchain-layers" aria-hidden="true">#</a> A Division of Blockchain Layers</h2><img src="https://pic.hanjiaming.com.cn/2024/11/21/18e4354ff779b.png" alt="1732141984019.png" style="zoom:50%;"><ul><li>Hardware Layer: <strong>(Trusted) Hardware</strong>：最底层的硬件层，包括计算机、服务器等物理设备。</li><li><strong>Layer 0</strong>：<strong>Networks (Public/Private)</strong>：这一层包括公共和私有网络，负责将不同设备连接起来，形成区块链网络的基础通信层。</li><li><strong>Layer 1</strong>： <ul><li><strong>Blockchains, side-chains</strong>：这一层是区块链的主链和侧链，负责处理和记录交易。它们通过共识机制（Consensus Mechanism）来确保网络的安全和一致性。</li><li>Consensus Mechanism(s)</li></ul></li><li><strong>Layer 2</strong>： <ul><li><strong>Channels</strong>：状态通道，允许用户在链下进行多次交易，仅在通道打开和关闭时将交易结果提交到区块链上。</li><li><strong>Commit-Chains</strong>：依赖一个中央中介，在可用性方面是受信任的，但在资金方面是不受信任的。</li><li><strong>Refereed-delegation</strong>：仲裁委托机制，通过第三方仲裁来确保交易的正确性和公平性。</li><li><strong>Payment, State, Network</strong>：Layer 2技术可以应用于支付、状态管理和网络层面，以提升区块链的扩展性和效率。</li></ul></li></ul><p>提交链：依赖于中央中介，在可用性方面受信任，但在资金方面不受信任</p><p><strong>P.S.侧链有自己的共识算法，即不是第 2 层</strong></p><h2 id="off-chain-tx-and-on-chain-deposit" tabindex="-1"><a class="header-anchor" href="#off-chain-tx-and-on-chain-deposit" aria-hidden="true">#</a> Off-chain tx and On-chain deposit</h2><ul><li>通过签名在链下处理多笔交易。 <ul><li>这意味着交易双方可以在不将每笔交易记录到区块链上的情况下，通过签名确认交易的有效性。</li></ul></li><li>每次签名后，不会在链上转移资金。</li></ul><p>Unidirectional case「单向交易情况」</p><ul><li>付款方仍然在交易上进行签名。</li><li>收款方可以将签名放到链上作为借据。</li></ul><p>Bidirectional case</p><ul><li>双方在链下的双人账本上签署余额。</li><li>即双方都需要在交易的余额上进行签名，以确认交易的有效性和余额的变动。</li></ul><p>但签名本身并不代表资金。即签名仅表示交易的确认，并不直接涉及资金的转移。</p><p>每个参与者在链上放置一次性“锁定”存款。</p><ul><li>区块链仅作为争议的追索手段。即如果交易过程中发生争议，可以通过区块链上的担保金额进行解决。</li><li>如果交易/争议能在链下解决，存款将保持不变。</li></ul><p>::: Details Example</p><p>假设Alice和Bob之间需要进行多次小额交易，他们不希望每次交易都记录在区块链上，因为这样会产生高额的交易费用和延迟。</p><p>Alice和Bob可以通过链下交易机制进行交易，只有在最终结算时才将交易结果记录在区块链上。</p><p>链下交易可以减少交易费用和延迟，提高交易效率。</p><ol><li>创建支付通道 <ul><li>Alice和Bob各自存入一定金额到区块链上作为担保。</li></ul></li><li>进行链下交易 <ul><li>Alice向Bob支付10元，通过签名确认交易。</li><li>Bob确认收到10元，通过签名确认交易。</li></ul></li><li>记录最终结果 <ul><li>双方进行多次链下交易后，将最终的交易结果记录在区块链上。</li></ul></li></ol><p>假设Alice和Bob进行5次交易，最终Alice支付给Bob 50元。最终，他们在区块链上记录的交易结果是Alice支付给Bob 50元，减少了多次交易的费用和延迟。</p><p>:::</p><h2 id="using-a-payment-channel" tabindex="-1"><a class="header-anchor" href="#using-a-payment-channel" aria-hidden="true">#</a> Using a Payment Channel</h2><p>Bidirectional transfers between 2 participants</p><ul><li>只要他们的传输净额不超过链上存入的代币总额，他们就可以无限次地进行交易。</li><li>只有净额的一笔交易会被记录在区块链上，这样可以大大减少交易次数和费用。</li><li>通过减少链上交易次数，可以最小化交易费用，只需支付一次费用。</li></ul><p>如果付款人“过度承诺「overcommit」”并支付给太多人会怎样？</p><ul><li>例如，链上有5美元，但支付2美元给B和4美元给C，这样总支付额超过了链上的存款。</li><li>如果一个人的抵押品是为了多个收款人，则无法检测到过度承诺的情况。</li><li>因此，付款人需要为每个潜在的收款人锁定资金。</li><li>也就是说，需要为每个收款人设置一个支付通道。</li><li>他们可以选择最终关闭通道。例如，当没有未完成的链下交易时。</li></ul><details class="hint-container details"><summary>Example</summary><p>假设Alice和Bob是两个朋友，他们经常相互借钱，但每次都要在区块链上记录交易，这样会产生高额的交易费用。</p><p>支付通道可以让Alice和Bob在不需要每次都记录交易的情况下进行多次交易，只有最终的净额会记录在区块链上，从而减少交易费用。</p><ol><li>Alice和Bob在区块链上创建一个支付通道，每人存入10美元。</li><li>在接下来的一个月里，Alice和Bob进行多次交易。例如，Alice支付3美元给Bob，Bob支付5美元给Alice。</li><li>最终，Alice和Bob决定关闭支付通道，计算净额。Alice支付给Bob的净额是3美元，Bob支付给Alice的净额是5美元，最终的净额是Alice支付2美元给Bob。</li><li>关闭通道时，只有这2美元的净额会记录在区块链上。</li></ol><p>最终，Alice和Bob只需支付一次交易费用来记录2美元的净额交易，而不是每次交易都支付费用。</p></details><h2 id="payment-channel-network-bitcoin" tabindex="-1"><a class="header-anchor" href="#payment-channel-network-bitcoin" aria-hidden="true">#</a> Payment Channel Network (Bitcoin)</h2><p>中本聪「Nakamoto」提出的“高频交易”「<strong>high-frequency transactions/trading</strong>」概念，旨在通过支付通道网络实现比特币的快速交易。</p><ul><li>两个或更多的参与方可以反复更新一笔未确认的交易。这意味着在交易被最终确认之前，参与方可以多次修改交易的内容。</li><li>多重签名：需要收集多个参与方的足够签名才能完成交易。</li><li>一笔未记录的交易可以在锁定时间之前不断被替换。这利用了NLockTime字段，确保交易在特定时间之前可以被修改。 <ul><li>NLockTime字段在未花费交易输出（UTXO）中的应用</li></ul></li><li>这种设计并不安全：一个参与方可能会与矿工勾结，提交一个非最终版本的交易，从而窃取其他参与方的资金。</li></ul><p>CLTV是一种比特币脚本操作码，用于设置交易的锁定时间，确保交易在特定时间之前无法被确认。</p><p>CSV是另一种比特币脚本操作码，用于设置交易的序列号，确保交易在特定的区块高度或时间之前无法被确认。</p><h2 id="major-payment-channel-networks" tabindex="-1"><a class="header-anchor" href="#major-payment-channel-networks" aria-hidden="true">#</a> (Major) Payment Channel Networks</h2><p>闪电网络「Lightning Network」（Poon-Dryja通道）是一种在比特币网络上实现的支付通道网络。</p><ul><li>它允许用户通过链下的微支付通道进行多次交易，仅在关闭通道时将最终交易结果提交到区块链上。</li><li>这种方式大大提高了交易速度和降低了交易成本。</li><li>闪电网络是一种基于支付通道的扩展解决方案，旨在提高比特币网络的交易速度和可扩展性。</li><li>它通过创建多个支付通道，使得用户可以进行快速、低费用的链下交易。</li></ul><details class="hint-container details"><summary>Use multi-signature</summary><p>假设Alice和Bob经常进行小额交易，但不希望每次交易都在区块链上进行，因为这样会产生高额的交易费用和较长的确认时间。</p><p>支付通道利用多重签名地址和链下交易机制，允许Alice和Bob在不频繁更新区块链的情况下进行多次交易。这不仅节省了费用，还提高了交易速度。</p><ol><li>Alice和Bob创建一个多重签名地址，并将各自的资金存入该地址（Alice存入0.01 BTC，Bob存入0.04 BTC）。</li><li>他们在支付通道账本上记录各自的初始余额。</li><li>Alice支付0.005 BTC给Bob，支付通道账本更新为Alice 0.005 BTC，Bob 0.045 BTC。</li><li>他们继续进行多次交易，直到决定关闭通道。</li><li>关闭通道时，最终余额记录在区块链上，并释放相应的资金。</li></ol><p>假设经过多次交易，最终Alice的余额为0.002 BTC，Bob的余额为0.048 BTC。在关闭通道时，这些余额将更新到区块链上，并释放到各自的地址。</p></details><h3 id="what-happened-off-chain" tabindex="-1"><a class="header-anchor" href="#what-happened-off-chain" aria-hidden="true">#</a> What happened off-chain?</h3><ul><li>支付通道账本是在链下更新的。</li><li>Alice 和 Bob 签署更新后的 balance 表</li><li>Each keeps a copy of it</li><li>爱丽丝可以继续购买，直到余额耗尽。</li><li>每秒钟的交易数量没有限制。 <ul><li>实际限制仅在于通信带宽和延迟</li></ul></li></ul><h3 id="what-happened-on-chain" tabindex="-1"><a class="header-anchor" href="#what-happened-on-chain" aria-hidden="true">#</a> What happened on-chain?</h3><p>支付通道可以在任何时间关闭。</p><ul><li><u><strong>支付通道是一种链下交易机制，允许双方在不记录每笔交易的情况下进行多次交易。</strong></u></li><li>关闭通道时，双方需要将最终的交易状态广播到区块链上，以确保资金的正确分配。</li></ul><p>任何一方都可以广播最新的链下账本（由双方签名）。</p><ul><li>无论哪一方都可以将最终的交易状态提交到区块链上，</li><li>前提是该状态已经得到双方的签名确认。</li></ul><p>矿工会验证签名并根据链下账本的汇总结果释放资金。</p><p>如果一方未能提供证明（例如，简单地消失了）怎么办？</p><ul><li>这会导致交易无法完成</li><li>资金将被永久锁定！如果一方消失或不合作，资金将无法被释放，导致资金永久锁定在支付通道中。</li><li>我们设置了一个超时机制。超时机制可以防止资金永久锁定的情况发生。如果在设定的时间内未完成交易，系统将自动执行预定的处理方式。</li></ul><p>最终的决定权在于提交的证明，假设没有更多的待处理交易（例如，一方消失且不会反驳）。这意味着在没有其他交易的情况下，提交的交易状态将被视为最终状态。</p><details class="hint-container details"><summary>Example</summary><p>假设Alice和Bob通过支付通道进行多次交易，最终Alice需要将5 BTC支付给Bob，但在交易过程中Bob突然失踪。</p><ol><li>Alice尝试联系Bob，但未能得到回应。</li><li>Alice等待设定的超时期限。</li><li>超时期限到达后，Alice可以单方面提交交易状态，并附上她的签名。</li><li>矿工验证Alice的签名和交易状态。</li><li>矿工根据链上规则释放资金，确保Alice的5 BTC支付给Bob。</li></ol><p>假设Alice在超时期限内提交了交易状态，矿工验证后，5 BTC将从Alice的账户转移到Bob的账户，支付通道关闭。</p></details><h3 id="the-3-phases-of-a-channel-s-lifetime" tabindex="-1"><a class="header-anchor" href="#the-3-phases-of-a-channel-s-lifetime" aria-hidden="true">#</a> The 3 Phases of A Channel’s Lifetime</h3><p>一个通道的生命周期通常分为三个阶段。</p><p>Establishment (the general n-party case)</p><ul><li>所有参与方通过在区块链上锁定抵押品，共同打开一个通道。</li><li>资金只能通过一致同意或预定义的退款条件释放</li></ul><p>Transition (the general state-transition case)</p><ul><li>一方通过签名（Sign）命令（cmd）提出一个新的状态 sᵢ ← T(sᵢ₋₁, cmd)。</li><li>T表示（抽象的）转换函数，例如，转账。</li><li>所有其他参与方重新计算状态转换，签名并发送给所有其他人。</li></ul><p>Dispute/Closure</p><ul><li>如果一个诚实的参与方在本地超时之前没有收到n个签名</li><li>它假设对提议的状态存在分歧。</li><li>诚实的参与方可能会触发第1层争议！</li><li>在没有其他参与方合作的情况下强制执行新的状态转换。</li></ul><details class="hint-container details"><summary>Example</summary><p>假设有三个参与者A、B和C，他们希望通过一个通道进行多次小额交易，而不每次都在区块链上记录。</p><p>他们决定在区块链上创建一个通道，并锁定一定的抵押品，以便在通道内进行交易。每次交易后，他们需要更新通道的状态，并在交易结束时进行结算。</p><p><strong>建立阶段</strong>：</p><ul><li>A、B和C在区块链上锁定一定的抵押品，共同打开一个通道。</li><li>他们约定只有在一致同意或预定义</li></ul><p><strong>转换阶段</strong>：</p><ul><li>A向B转账10个单位的资金，提出新的状态s₁ ← T(s₀, cmd)。</li><li>B和C重新计算状态转换，签名并发送给所有人。</li></ul><p><strong>争议/关闭阶段</strong>：</p><ul><li>如果A在本地超时之前没有收到B和C的签名，则假设存在争议。</li><li>A可以触发第1层争议，强制执行新的状态转换。</li></ul></details><div class="hint-container tip"><p class="hint-container-title">Payment Channel vs State Channel</p><ul><li>支付通道是通道的一种具体应用，用于在参与者之间进行多次小额支付，提高支付效率。</li><li>状态通道允许参与者在不直接在区块链上记录每次状态变化的情况下进行复杂的状态转换。</li></ul></div><h3 id="false-allayed-concerns" tabindex="-1"><a class="header-anchor" href="#false-allayed-concerns" aria-hidden="true">#</a> False/Allayed Concerns</h3><ul><li>我不想预先为未来的支付预付资金。</li><li>我不想锁定资金，以至于无法在其他地方使用它们。</li><li>用户担心每次需要补充资金时都要关闭和重新打开支付通道，这会很麻烦。</li><li>用户担心他们无法提前预知在特定商店的消费金额。 <ul><li>用户可以使用一个支付通道进行多次交易，而不需要为每个商店单独开通通道。</li></ul></li></ul><div class="hint-container info"><p class="hint-container-title">online vs. cold wallet</p><p>你常用的支付通道就像你的热钱包/消费钱包。</p><ul><li>这里将支付通道比作热钱包，表示它是在线的，可以随时进行交易。</li><li>对比你的“储蓄账户”和你的钱包。储蓄账户类似于冷钱包，更加安全但不便于频繁使用；</li><li>钱包则类似于热钱包，便于日常交易。</li></ul><p>支付通道和热钱包都是在线的，可以随时进行交易，而冷钱包是离线的，更加安全但不便于频繁使用。</p></div><h3 id="payment-channel-network-pcn" tabindex="-1"><a class="header-anchor" href="#payment-channel-network-pcn" aria-hidden="true">#</a> Payment Channel Network (PCN)</h3><p>在支付通道网络中，路由问题「Routing problem」是指如何找到一条最优路径，使得资金可以从一个节点传递到另一个节点。这条路径需要满足资金充足、费用最低和时间最短等要求。</p><p>支付通道网络的目标是找到从节点A到节点B的最快且最便宜的路径。这意味着我们需要考虑每条路径的资金充足性、交易费用以及传输时间。</p><p>中介节点会收取一定的手续费以转发交易。</p><h2 id="multi-hop-payment-atomicity-and-htlc" tabindex="-1"><a class="header-anchor" href="#multi-hop-payment-atomicity-and-htlc" aria-hidden="true">#</a> Multi-hop Payment Atomicity and HTLC</h2><p>Atomicity「原子性」: 路径中所有通道的容量要么全部更新，要么全部不变。</p><p>原子性确保了在多跳支付过程中，所有相关通道的状态要么全部成功更新，要么全部不更新，从而避免部分更新导致的资金损失。</p><p>部分更新可能导致路径上的用户损失。比如，如果在多跳支付过程中，某一跳成功支付但下一跳失败，那么中间节点可能会遭受损失。</p><p>解决方案：哈希时间锁定合约（Hash Time-Lock Contract (HTLC)）。HTLC是一种智能合约，结合了加密哈希函数和时间锁定机制，用于确保多跳支付的原子性。</p><p>HTLC是闪电网络中常用的技术，帮助实现快速和安全的多跳支付。</p><ul><li>使用加密哈希函数H。HTLC中使用哈希函数来生成一个唯一的哈希值，用于验证支付条件。</li><li>s：加密证明。s是一个秘密值，通过哈希函数生成哈希值H(s)，用于验证支付条件。</li></ul><p>为什么使用s？因为我们会有多个基于H(s)的合约。通过使用相同的哈希值H(s)，可以在多个支付通道之间建立关联，确保支付的原子性。</p><img src="https://pic.hanjiaming.com.cn/2024/11/23/8db41cb625b0d.png" alt="1732305958670.png" style="zoom:50%;"><h2 id="cryptocurrency-exchange" tabindex="-1"><a class="header-anchor" href="#cryptocurrency-exchange" aria-hidden="true">#</a> Cryptocurrency Exchange</h2><p>两笔交易的原子性 =&gt; 公平交换</p><ul><li>这也解决了原子跨链交换（ACCS）问题</li><li>跨链交易指的是在不同区块链之间进行资产的交换。</li><li>原子性：两笔交易要么都提交，要么都取消</li></ul><h3 id="centralized-solution" tabindex="-1"><a class="header-anchor" href="#centralized-solution" aria-hidden="true">#</a> Centralized Solution</h3><img src="https://pic.hanjiaming.com.cn/2024/11/23/4e11b914afaad.png" alt="1732306291151.png" style="zoom:50%;"><h3 id="decentralized-solution-using-htlc" tabindex="-1"><a class="header-anchor" href="#decentralized-solution-using-htlc" aria-hidden="true">#</a> Decentralized Solution using HTLC</h3><p>Alice和Bob希望进行跨链交易，Alice用10个以太币换取Bob的1个比特币。</p><ol><li>Alice选择一个随机的密钥s，并计算其哈希值h。</li><li>Alice在以太坊区块链上部署一个哈希锁合约，输入为s。如果H(s) == h，则10个以太币发送给Bob；如果时间超过Δ，则退款给Alice。</li><li>Bob复制Alice的哈希锁h，并在比特币区块链上部署一个类似的哈希锁合约，输入为s。如果H(s) == h，则1个比特币发送给Alice；如果时间超过Δ，则退款给Bob。</li><li>Alice通过揭示s来解锁Bob的哈希锁，Bob也会知道s。</li><li>Bob使用s解锁Alice的哈希锁，完成交易。</li></ol><p>假设Alice选择的随机密钥s为“1234”，其哈希值h为“abcd”。Alice和Bob按照上述步骤完成交易，最终Alice获得1个比特币，Bob获得10个以太币。</p><h2 id="wormhole-attack" tabindex="-1"><a class="header-anchor" href="#wormhole-attack" aria-hidden="true">#</a> Wormhole Attack</h2><p>攻击者通过操纵网络，使得某些交易被跳过，从而窃取这些交易的费用。</p><p>攻击者跳过的交易越多，他们能够窃取的交易费用也就越多，从而获得更高的收益。</p><p>被跳过的受害者会遭受以下损失</p><ul><li>希望获得交易费用（但未能如愿）</li><li>资金被锁定了一段时间（但未能获得费用）</li><li>失去了其他获得交易费用的机会</li></ul><p>受害者无法轻易判断自己是否遭受了攻击</p><ul><li>他们是否正在遭受攻击</li><li>受害者也可能认为支付失败是由于其他原因导致的。 <ul><li>例如，通道中没有足够的币，一个用户离线等。</li></ul></li></ul><p>由于虫洞攻击的存在，诚实用户可能会失去参与网络的动机。</p><p>对于所有需要两次通信轮次的多跳支付协议。</p><ul><li>通信轮次是指支付路径的完整遍历一次。</li><li>可以是向前遍历（例如，用于设置支付）。</li><li>或者是向后遍历（例如，用于释放资金）。</li></ul><p>在不使用广播信道的情况下，存在一个容易受到虫洞攻击的路径。</p><details class="hint-container details"><summary>Example</summary><p>假设我们有一个多跳支付协议，支付方A需要通过中间节点B和C将资金支付给接收方D。</p><p>整个支付过程需要两次通信轮次：第一次用于设置支付路径，第二次用于确认支付并释放资金。</p><p>在没有使用广播信道的情况下，A和D之间的支付路径可能会被攻击者劫持，导致支付失败或资金被盗。攻击者可以通过创建一个虚假的捷径路径（虫洞）来截获支付信息。</p><ol><li>A向B发送支付请求，B向C转发请求，C最终将请求发送给D。</li><li>D确认支付请求并通过相同路径返回确认信息。</li><li>攻击者在B和C之间创建一个虚假的捷径路径，截获并篡改支付信息。</li><li>A和D之间的支付失败，资金可能被攻击者盗取。</li></ol></details>',96),o=[t];function c(s,r){return l(),e("div",null,o)}const d=i(n,[["render",c],["__file","channel.html.vue"]]);export{d as default};
