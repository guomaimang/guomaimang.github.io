import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as i,e as t}from"./app-1678f25e.js";const l={},s=t('<h1 id="db-storage-servers" tabindex="-1"><a class="header-anchor" href="#db-storage-servers" aria-hidden="true">#</a> DB Storage Servers</h1><h2 id="two-paradigms-of-db-storage" tabindex="-1"><a class="header-anchor" href="#two-paradigms-of-db-storage" aria-hidden="true">#</a> Two Paradigms of DB Storage</h2><h3 id="relational-databases" tabindex="-1"><a class="header-anchor" href="#relational-databases" aria-hidden="true">#</a> Relational Databases</h3><ul><li>Structured in tables (row and columns): Slow but powerful</li><li>Harder to scale</li><li>Accessible through the Structured Query Language (SQL)</li><li>Often used as persistence storage</li><li>Examples: MySQL (free), MSSQL, Oracle, SQLite (free), etc.</li></ul><h3 id="nosql-databases-non-sql-or-non-relational" tabindex="-1"><a class="header-anchor" href="#nosql-databases-non-sql-or-non-relational" aria-hidden="true">#</a> NoSQL Databases: &quot;non-SQL&quot; or &quot;non-relational&quot;</h3><ul><li>The name &quot;NoSQL&quot; was only coined„ÄåÂàõÈÄ†„Äç in the early 21st century</li><li>Unstructured (document: JSON-like data; key-value store, ...) as a tradeoff for speed</li><li>Easy to scale-out</li><li>Accessible through API</li><li>Optimized for speed, thus often as an in-memory cache</li><li>For applications that mostly query (vs. update) in <strong>async. manner</strong></li><li><strong>Inaccuracy can be tolerated</strong> by the application (see later slides)</li><li>Examples: Redis (free), Memcached (free), MongoDB, etc.</li></ul><h2 id="sqlite" tabindex="-1"><a class="header-anchor" href="#sqlite" aria-hidden="true">#</a> SQLite</h2><ul><li>Lightweight in design, Best for single-user apps (MobileApps/Simple WebApps)</li><li>Stores everything in a single file, Easy to embed, test, backup, and transfer</li><li>Simple access-right management <ul><li>Simple access-right management</li><li>Simply depending/relying on the file access rights</li></ul></li></ul><h2 id="mysql" tabindex="-1"><a class="header-anchor" href="#mysql" aria-hidden="true">#</a> MySQL</h2><ul><li>Dual-licensing: / (if you don&#39;t need support), or proprietary</li><li>Relational DB: Table structure</li><li>Full-featured, accessible using SQL <ul><li>But heavyweight, quite slow</li><li>Relatively powerful considering it is something for free</li><li>Access Control and Account Management</li></ul></li><li>Supported by multi-platforms</li></ul><h2 id="redis" tabindex="-1"><a class="header-anchor" href="#redis" aria-hidden="true">#</a> Redis</h2><p>(Remote Dictionary Server)</p><ul><li>Open-source NoSQL DB</li><li>Cache: In-memory DB as a key-value store (hence, very fast)</li><li>Supports a rather rich set of other data structures <ul><li>strings, lists, sorted sets, bitmaps, geospatial indexes</li></ul></li><li>Common use cases: <ul><li>To serve queries, i.e., GET requests <ul><li>e.g., cache your templates to prevent re-rendering</li><li>When to expire? Expire on DB update?</li></ul></li><li>To completely serve as a DB <ul><li>Data loss when the machine is down (it&#39;s in-memory)</li><li>Periodically backup data to persistent storage</li><li>Best of both worlds of Mongo<strong>DB</strong> , Mem<strong>cache</strong>d</li></ul></li></ul></li><li>Basically, no support üò¶</li><li>Support some simple authentication</li><li>Can be restricted to certain interfaces</li><li>No data encryption (slow for a very large DB)</li></ul><h2 id="nosql-database" tabindex="-1"><a class="header-anchor" href="#nosql-database" aria-hidden="true">#</a> NoSQL Database</h2><p>Big Data --&gt; Scalability</p><ul><li>Flexible schema: ideal for unstructured data</li><li>Distributed processing (pair with Map reduce, clusters)</li><li>Designed to handle massive storage</li><li>Live with <strong>the</strong> (see the next slide)</li></ul><p>Data Analysis vs. Data Modification</p><ul><li>Few/no updates on data, e.g., data stream (e.g., user browsing trace)</li><li>Mostly query (e.g., See which product is mostly viewed)</li><li>Need to get results quickly</li></ul><h2 id="cap-theorem" tabindex="-1"><a class="header-anchor" href="#cap-theorem" aria-hidden="true">#</a> CAP Theorem</h2><p><strong>Core Requirements of Distributed Systems</strong></p><p>Trilemma, you can only choose two (and relax the remaining)</p><ul><li>C&amp;A: Traditional RDBMS (single-node vs master-slave vs sharding); but we focus on &quot;network partition&quot;</li><li>C&amp;P: Redis (not accepting write for minority)</li><li>A&amp;P: (Eventual Consistent)</li></ul><p>What if no network partition? PACELC Theorem</p><img src="https://pic.hanjiaming.com.cn/2025/04/07/3fcfb876b5b3b.png" alt="È¢ÑËßà 2025-04-07 12.32.00.png" style="zoom:75%;"><h2 id="sql-or-nosql" tabindex="-1"><a class="header-anchor" href="#sql-or-nosql" aria-hidden="true">#</a> SQL or NoSQL?</h2><h3 id="acid-compliant" tabindex="-1"><a class="header-anchor" href="#acid-compliant" aria-hidden="true">#</a> ACID-compliant</h3><p>Traditional databases (C&amp;A) focus on ACID (NoSQL can also be ACID-compliant)</p><ul><li>Atomicity. whole transaction as a unit: success completely or fail</li><li>Consistency. A transaction updates the DB consistently according to the &quot;rules&quot;</li><li>Isolation. Adjustable interference of concurrent transaction execution, e.g., read-write</li><li>Durability. Committed transactions remain in effect in case of system failure.</li></ul><h3 id="nosql-base" tabindex="-1"><a class="header-anchor" href="#nosql-base" aria-hidden="true">#</a> NoSQL: BASE</h3><ul><li>Basic Availability, Soft state, Eventual consistency</li><li>Weak consistency ??? Stale„ÄåÈôàÊóßÁöÑ„Äç data OK (Eventual„ÄåÊúÄÁªà„Äç consistency)</li><li>Basically Available (part of the data may be temporarily unavailable)</li><li>Easily scale out (e.g., sharding by &quot;key&quot;): add/remove nodes in the cluster</li><li>Simpler and faster</li></ul><h2 id="different-data-models-for-nosql" tabindex="-1"><a class="header-anchor" href="#different-data-models-for-nosql" aria-hidden="true">#</a> Different Data Models for NoSQL</h2><ul><li>Key-Value Store -&gt; Collection of key/value pairs</li><li>Column-family System (multidimensional sorted map) <ul><li>a key-value store but further structures the value into families</li><li>Very light &quot;schema&quot;: (rowKey, colKey, timestamp) -&gt; value <ul><li>e.g., url as row keys, and &quot;component&quot; of a web as the value</li><li>e.g. BigTable, Hadoop HBase</li></ul></li></ul></li><li>Document-based <ul><li>Documents with tags, metadata, or a certain structure</li><li>e.g., pdf, xml, etc.</li></ul></li><li>Graph-based, E.g., Neo4j</li></ul><h2 id="database-abstraction-layer" tabindex="-1"><a class="header-anchor" href="#database-abstraction-layer" aria-hidden="true">#</a> Database Abstraction Layer</h2><ul><li>A universal interface for accessing to different databases</li><li>Coding Consistency„Äå‰∏ÄËá¥ÊÄß„Äç: Regardless of the DB, use the same set of code</li><li>Single Interface: Easy to switch database without code modifications</li></ul><figure><img src="https://pic.hanjiaming.com.cn/2025/04/07/1b7246e45ec07.png" alt="1744008510147.png" tabindex="0" loading="lazy"><figcaption>1744008510147.png</figcaption></figure><h2 id="database-integrity-and-constraints" tabindex="-1"><a class="header-anchor" href="#database-integrity-and-constraints" aria-hidden="true">#</a> Database Integrity and Constraints</h2>',36),r=[s];function o(n,d){return a(),i("div",null,r)}const h=e(l,[["render",o],["__file","db.html.vue"]]);export{h as default};
