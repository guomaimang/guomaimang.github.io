import{_ as l}from"./plugin-vue_export-helper-c27b6911.js";import{o as i,c as t,e as a,a as s,b as e}from"./app-0df2b16c.js";const n={},c=a('<h1 id="spatial-clustering" tabindex="-1"><a class="header-anchor" href="#spatial-clustering" aria-hidden="true">#</a> Spatial Clustering</h1><p>Why Density-Based Clustering methods「基于密度的聚类方法」?</p><ul><li>发现任意形状的簇</li><li>簇「cluster」 – 物体密集区域被低密度区域分隔开来</li></ul><p>DBSCAN – the first density based clustering</p><p>DBSCAN -&gt; Density Based Spatial Clustering of Applications with Noise 「基于密度的噪声应用空间聚类」</p><ul><li><strong>基于密度的集群概念</strong>：这意味着数据点被分组（或聚集）在一起基于它们的“密度”，即数据点的紧密程度。想象一下，你有很多点散布在一张纸上，那些彼此靠近的点会形成一个“群体”或集群。</li><li><strong>集群被定义为密度连接点的最大集合</strong>：在这里，“集群”是指一群彼此靠得很近的点。所谓“密度连接”，就是指一个点的周围有足够多的其他点，使得它们可以被视为一个单一的组或集群。</li><li><strong>在有噪声的空间数据库中发现任意形状的集群</strong>：这表明这种方法能够在包含许多随机分布（即“噪声”）的数据中找到集群，而且这些集群可以是任何形状的，不仅仅是圆形或椭圆形。</li></ul><img src="https://pic.hanjiaming.com.cn/2023/11/20/aaeee8e861b41.png" alt="1700472279847.png" style="zoom:40%;"><h2 id="density-based-clustering" tabindex="-1"><a class="header-anchor" href="#density-based-clustering" aria-hidden="true">#</a> Density Based Clustering</h2><p>基本思想形式化的直觉：</p><ul><li>对于簇中的任何点，该点周围的局部点密度必须超过某个阈值</li><li>一个群组的点集在空间上是相连的</li></ul><p>由两个参数定义的点 p 处的局部点密度</p>',11),o=s("ul",null,[s("li",null,[s("strong",null,"ε"),e(" - 点 p 附近的半径: "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"N"),s("mi",null,"ε")]),s("mo",{stretchy:"false"},"("),s("mi",null,"p"),s("mo",{stretchy:"false"},")"),s("mo",null,":"),s("mo",null,"="),s("mo",{stretchy:"false"},"{"),s("mi",null,"q"),s("mtext",null," in data set "),s("mi",null,"D"),s("mo",null,"∣"),s("mi",{mathvariant:"normal"},"dist"),s("mo",null,"⁡"),s("mo",{stretchy:"false"},"("),s("mi",null,"p"),s("mo",{separator:"true"},","),s("mi",null,"q"),s("mo",{stretchy:"false"},")"),s("mo",null,"≤"),s("mi",null,"ε"),s("mo",{stretchy:"false"},"}")]),s("annotation",{encoding:"application/x-tex"},"N_{\\varepsilon}(p):=\\{q \\text { in data set } D \\mid \\operatorname{dist}(p, q) \\leq \\varepsilon\\}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.10903em"}},"N"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.1514em"}},[s("span",{style:{top:"-2.55em","margin-left":"-0.109em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"ε")])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"p"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},":="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"{"),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"q"),s("span",{class:"mord text"},[s("span",{class:"mord"}," in data set ")]),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"D"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"∣"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mop"},[s("span",{class:"mord mathrm"},"dist")]),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"p"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"q"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"≤"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal"},"ε"),s("span",{class:"mclose"},"}")])])]),e("， like 圆的半径就是ε")]),s("li",null,"MinPts - 给定邻域中的最小点数 N(p) 【至少需要有多少个点，个区域才能被认为是“密集”的，从而形成一个集群。】")],-1),r=s("details",{class:"hint-container details"},[s("summary",null,"Example"),s("p",null,"假设你在一个海滩上放飞无人机，无人机的相机可以看到下面的人。你要用这个无人机来找出海滩上的热门区域。"),s("p",null,"使用ε，你设置了无人机相机的焦距，定义了它能清晰看到地面上的一个特定大小的区域。比如说，你把焦距设置得能看到直径为10米的圆形区域。"),s("p",null,"接下来，你决定至少要在这个10米直径的圆形区域内看到15个人，这个区域才算是热门的。这个“15”就是你的MinPts。"),s("p",null,"现在，无人机飞过海滩，每次都在地面上标记出一个10米的圆形区域，并数里面的人。如果一个圆形区域内有15个或更多的人，那么这个区域就被标记为热门区域，或者说是一个“集群”。如果人少于15个，那么这个区域就被忽略了，因为它没有达到你设置的密集标准。通过这种方式，无人机可以帮你找到海滩上所有的热门区域。")],-1),m=s("h2",{id:"ε-neighborhood",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#ε-neighborhood","aria-hidden":"true"},"#"),e(" ε-Neighborhood")],-1),p=s("p",null,"ε-Neighborhood: 距物体 ε 半径内的物体。",-1),d=s("p",{class:"katex-block"},[s("span",{class:"katex-display"},[s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[s("semantics",null,[s("mrow",null,[s("msub",null,[s("mi",null,"N"),s("mi",null,"ε")]),s("mo",{stretchy:"false"},"("),s("mi",null,"p"),s("mo",{stretchy:"false"},")"),s("mo",null,":"),s("mo",null,"="),s("mo",{stretchy:"false"},"{"),s("mi",null,"q"),s("mtext",null," in data set "),s("mi",null,"D"),s("mo",null,"∣"),s("mi",{mathvariant:"normal"},"dist"),s("mo",null,"⁡"),s("mo",{stretchy:"false"},"("),s("mi",null,"p"),s("mo",{separator:"true"},","),s("mi",null,"q"),s("mo",{stretchy:"false"},")"),s("mo",null,"≤"),s("mi",null,"ε"),s("mo",{stretchy:"false"},"}")]),s("annotation",{encoding:"application/x-tex"}," N_{\\varepsilon}(p):=\\{q \\text { in data set } D \\mid \\operatorname{dist}(p, q) \\leq \\varepsilon\\} ")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.10903em"}},"N"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.1514em"}},[s("span",{style:{top:"-2.55em","margin-left":"-0.109em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mathnormal mtight"},"ε")])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"p"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},":="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"{"),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"q"),s("span",{class:"mord text"},[s("span",{class:"mord"}," in data set ")]),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"D"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"∣"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mop"},[s("span",{class:"mord mathrm"},"dist")]),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"p"),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"q"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"≤"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal"},"ε"),s("span",{class:"mclose"},"}")])])])])],-1),h=a('<p>“高密度”- 对象的 ε-Neighborhood 至少包含 MinPts 个对象。</p><img src="https://pic.hanjiaming.com.cn/2023/11/20/dd96569702632.png" alt="1700474737732.png" style="zoom:33%;"><div class="hint-container danger"><p class="hint-container-title">MinPts</p><p>ε-Neighborhood 至少包含 MinPts 个对象，计数包含中心本身。</p></div><h2 id="core-border-outlier" tabindex="-1"><a class="header-anchor" href="#core-border-outlier" aria-hidden="true">#</a> Core, Border &amp; Outlier</h2><p>给定 ε 和 MinPts，我们可以将对象分为三个不同的组。</p><ul><li>如果一个点在 Eps 范围内的点数（MinPts）超过指定数量，则该点为 core point。这些点位于群集的内部。</li><li>border point 在 Eps 范围内的最小点数少于 MinPts，但位于核心点附近。</li><li>noise point/outlier 是指任何既不是核心点也不是边界点的点。</li></ul><img src="https://pic.hanjiaming.com.cn/2023/11/20/2a90538234e18.png" alt="1700476026016.png" style="zoom:33%;"><p>在下面的 Example, M、P、O 和 R 是core point（在 Q、M、P、S、O、R 中），因为它们每个都位于包含至少 3 个点的 ε-Neighborhood 中</p><img src="https://pic.hanjiaming.com.cn/2023/11/20/ef962f148f070.png" alt="1700476237789.png" style="zoom:33%;"><h2 id="density-reachability" tabindex="-1"><a class="header-anchor" href="#density-reachability" aria-hidden="true">#</a> Density Reachability</h2><h3 id="directly-density-reachable" tabindex="-1"><a class="header-anchor" href="#directly-density-reachable" aria-hidden="true">#</a> Directly Density-Reachable</h3><ul><li>如果 p 是核心对象，</li><li>且 q 位于 p 的 ε-Neighborhood 中，</li></ul><p>则object <em>q</em> is <strong>directly density-reachable</strong> <u>from object <em>p</em></u></p><img src="https://pic.hanjiaming.com.cn/2023/11/20/00f90966717fb.png" alt="1700477634996.png" style="zoom:33%;"><div class="hint-container warning"><p class="hint-container-title">特别注意</p><p>是两个条件都要成立，而且</p><ul><li>q 是从 p 直接密度可达的</li><li>p 不是从 q 直接密度可达的</li><li>密度可达性是不对称的</li></ul></div><h3 id="indirectly-density-reachable" tabindex="-1"><a class="header-anchor" href="#indirectly-density-reachable" aria-hidden="true">#</a> Indirectly Density-Reachable</h3><ul><li>p 是从p2 直接密度可达的；</li><li>p2 是从p1 直接密度可达的；</li><li>p1 是从 q 直接密度可达的；</li></ul><p>p &lt;- p2 &lt;- p1 &lt;- q 形成一条链</p><img src="https://pic.hanjiaming.com.cn/2023/11/20/bc67053406bb7.png" alt="1700477977891.png" style="zoom:33%;"><p><em>p</em> is (indirectly) density-reachable from <em>q</em></p><h2 id="density-connectivity" tabindex="-1"><a class="header-anchor" href="#density-connectivity" aria-hidden="true">#</a> Density-Connectivity</h2><ul><li>Density-Reachable is not symmetric, not good enough to describe clusters.</li><li>Density-Connected: 如果一对点 p 和 q 从点 o 密度可达，则它们是密度连通的。 <ul><li>密度连通性是对称的</li></ul></li></ul><img src="https://pic.hanjiaming.com.cn/2023/11/20/3151544779b60.png" alt="1700478156708.png" style="zoom:33%;"><h2 id="formal-description-of-cluster" tabindex="-1"><a class="header-anchor" href="#formal-description-of-cluster" aria-hidden="true">#</a> Formal Description of Cluster</h2><ul><li>Given a data set <em>D</em>, parameter ε and threshold MinPts.</li><li>集群 C 是满足下面三个标准的对象子集（具有核心点和边界点） <ul><li><em>Connected:</em> ∀ <em>p</em>,<em>q</em> ∈ <em>C</em>: <em>p</em> and <em>q</em> are density-connected.</li><li><em>Maximal:</em> ∀ <em>p</em>,<em>q</em>: if <em>p</em> ∈ <em>C</em> and if <em>q</em> is density-reachable from <em>p</em> (p is a core point), then <em>q</em> ∈ <em>C</em>.</li></ul></li></ul><div class="hint-container tip"><p class="hint-container-title">提示</p><p>一个团队就像是一个集群，因为其成员之间都是相互连接的，并且它包括了所有通过团队成员可以相互到达的人，没有遗漏。</p></div><img src="https://pic.hanjiaming.com.cn/2023/11/20/41dfcab57f1a1.png" alt="1700479099668.png" style="zoom:33%;"><h2 id="dbscan-the-algorithm" tabindex="-1"><a class="header-anchor" href="#dbscan-the-algorithm" aria-hidden="true">#</a> DBSCAN: The Algorithm</h2><h3 id="初始化" tabindex="-1"><a class="header-anchor" href="#初始化" aria-hidden="true">#</a> 初始化</h3><ul><li>设定参数<code>ε</code>（邻域大小）和<code>MinPts</code>（成为核心点所需的最小邻居数）。</li><li>创建两个空列表：<code>clusters</code>用于存储集群的集合，<code>noise</code>用于存储噪声点。</li><li>创建一个集合<code>visited</code>用于跟踪已经访问过的点。</li><li>数据集中的每个点都会被标记为未访问。</li></ul><h3 id="程序主体" tabindex="-1"><a class="header-anchor" href="#程序主体" aria-hidden="true">#</a> 程序主体</h3><p>对于数据集中的每个点<code>p</code>：</p><ol><li>检查 <code>visited</code> 集合来确定<code>p</code>是否已经处理。<strong>如果<code>p</code>已经访问过，则跳过此点</strong>。</li><li><strong>将<code>p</code>标记为已访问</strong>（将 <code>p</code> 添加到 <code>visited</code> 集合）</li><li>获取<code>p</code>的 ε-Neighborhood 中的所有点， 即执行一个范围查询，找出所有与p的距离小于等于ε的点</li><li>检查邻居数量是否少于 <code>MinPts</code> 。 <ul><li>如果是，将 p 标记为噪声点，添加到 noise 列表，然后继续处理下一个点。(即进行下一个循环周期)</li><li>如果不是，继续下一步来形成一个新的集群。</li></ul></li><li>创建一个新的集群<code>C</code>，并将<code>p</code>添加到<code>C</code>（这里C是一个新的列表或集合）</li><li>将<code>p</code>的所有邻居加入到<code>C</code>。这些邻居现在是p的直接密度可达点。</li><li>对于<code>C</code>中的每个点<code>q</code><ol><li>如果<code>q</code>未访问 <ol><li>将q标记为已访问，添加到<code>visited</code>集合中。</li><li>获取q的 ε-Neighborhood 中的所有点， 即执行一个范围查询，找出所有与q的距离小于等于ε的点</li><li>如果q的ε-邻域中至少有MinPts个点，这意味着q是一个核心点。因此，你将q的所有未处理的邻居点加入集群C。</li></ol></li><li>如果<code>q</code>访问，需要再次获取q的ε-邻域或标记q，因为这已经在之前的步骤中完成。</li><li>这个过程是递归的，意味着我们不仅查看直接邻居，还要查看邻居的邻居，以此类推。</li></ol></li><li><strong>当<code>C</code>中没有更多的点可以加入时</strong>，当前集群完成。 将<code>C</code>加入到<code>clusters</code>列表中。</li></ol><p><strong>重复这个过程，直到所有点都被访问</strong>。</p><img src="https://pic.hanjiaming.com.cn/2023/11/20/8e89b2124bcd6.png" alt="1700484681806.png" style="zoom:33%;"><img src="https://pic.hanjiaming.com.cn/2023/11/20/d13c0c63d43ce.png" alt="1700484746906.png" style="zoom:33%;"><ul><li><strong>Resistant to Noise</strong></li><li><strong>Can handle clusters of different shapes and sizes</strong></li></ul><img src="https://pic.hanjiaming.com.cn/2023/11/20/36731f681ef2b.png" alt="1700484833495.png" style="zoom:33%;"><ul><li>对参数敏感！</li><li>无法处理不同的密度！</li></ul><h2 id="determining-parameters" tabindex="-1"><a class="header-anchor" href="#determining-parameters" aria-hidden="true">#</a> Determining Parameters</h2><p>确定DBSCAN算法中的参数<code>ε</code>（邻域大小）和<code>MinPts</code>（最小点数）是一个挑战，因为这些参数会直接影响到算法能够识别出的集群的数量和大小。</p><ul><li>Cluster: 在一个区域内，如果点的数量（密度）超过了我们设定的门槛，那么这个区域就可以被称作一个集群。</li><li>想法：为了找出合适的参数，我们可以考虑数据集中最不密集的那些集群。我们希望即使是这些不那么明显的集群，也能够被算法识别出来。</li><li>一种找出<code>ε</code>的方法是观察数据点到其第k近邻的距离。这个距离可以帮助我们估计出<code>ε</code>的大小。</li></ul><figure><img src="https://pic.hanjiaming.com.cn/2023/11/20/bd7bd9b5a674a.png" alt="1700485392845.png" tabindex="0" loading="lazy"><figcaption>1700485392845.png</figcaption></figure><ul><li><strong>k-distance函数</strong>：这是一个函数，它告诉我们每个点和它的第k个最近邻居的距离是多少。</li><li><strong>k-distance图</strong>：这是一个图表，它按照距离从大到小排列了所有点的k-distance值。</li></ul><p>步骤</p><ol><li><strong>确定MinPts</strong>：<code>MinPts</code>是一个阈值，决定了一个点需要多少个邻居才能被认为是一个核心点。这个值通常取决于数据的维度（d）。一个常用的方法是将<code>MinPts</code>设为<code>2 * (d - 1)</code>。所谓维度，就是描述数据点的属性数量。比如，在一个二维空间中，每个点由两个坐标（比如x和y）来描述。</li><li><strong>选择边界对象o</strong>：在<code>MinPts</code>-距离图上，用户选择一个所谓的“边界对象”。这个对象代表了边界点和核心点之间的临界点。</li><li><strong>设定ε</strong>：一旦选择了边界对象o，<code>ε</code>就被设定</li></ol><figure><img src="https://pic.hanjiaming.com.cn/2023/11/20/457e8411a7acd.png" alt="1700485875539.png" tabindex="0" loading="lazy"><figcaption>1700485875539.png</figcaption></figure><p>假设你正在分析一个三维空间中的星系数据（因此d=3）。根据上述公式，你将<code>MinPts</code>设为<code>2 * (3 - 1) = 4</code>。这意味着一个星系需要至少有4个邻近星系才能被认为是一个集群的核心部分。</p><p>然后，你绘制了一个<code>MinPts</code>-距离图，这个图显示了每个星系与其第4个最近邻星系的距离。在这个图上，你注意到有一个特定的星系o，它的第4个最近邻的距离突然比周围星系的距离大了很多。这个距离可能是100光年。</p><p>因此，你将<code>ε</code>设定为100光年。这意味着在你的星系数据中，如果一个星系在100光年的范围内至少有4个邻居，那么它就可以被视为一个集群的一部分。</p><h2 id="discussion" tabindex="-1"><a class="header-anchor" href="#discussion" aria-hidden="true">#</a> Discussion</h2><p>优势</p><ul><li>聚类可以有任意的形状和大小</li><li>可自动确定聚类的数量</li><li>可将聚类从周围的噪音中分离出来</li></ul><p>缺点</p><ul><li>输入参数可能难以确定</li><li>在某些情况下对输入参数设置非常敏感</li></ul>',55),g=[c,o,r,m,p,d,h];function u(y,b){return i(),t("div",null,g)}const x=l(n,[["render",u],["__file","spatial-clustering.html.vue"]]);export{x as default};
