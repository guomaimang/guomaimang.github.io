import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as i,c as o,e as l}from"./app-075a1127.js";const c={},n=l('<h1 id="basic-unix-linux" tabindex="-1"><a class="header-anchor" href="#basic-unix-linux" aria-hidden="true">#</a> Basic Unix/Linux</h1><h2 id="命令还是程序" tabindex="-1"><a class="header-anchor" href="#命令还是程序" aria-hidden="true">#</a> 命令还是程序</h2><p>UNIX 和 Linux 中使用的大多数命令实际上是存储在某个地方的系统程序（通常存储在 /bin或 /usr /bin中）。</p><p>您通常会看到一个<code>$</code>标志或一个<code>％</code>标志，或者可能更多。 这称为提示，计算机期望接收您的命令。typically <code>%</code> (for C shell) or <code>$</code> (for bash).</p><p>UNIX和Linux中的约定：在提示下执行 指定名称的文件。</p><ul><li><strong>a.out</strong> and <strong>hello</strong> are names of your file and you can directly execute them by typing their names.</li><li><strong>ls</strong>, <strong>cp</strong>, <strong>pico</strong>, <strong>nano</strong> and <strong>(g)cc</strong> are all commands that you can find their executable files.</li></ul><p>可以用分号将几个命令分开，一次性给出 <code> ls; pwd; cal</code>将创建三个进程，依次执行三个命令（<code>ls</code>、<code>pwd</code>和<code>cal</code>）。</p><h2 id="bash-内置的命令" tabindex="-1"><a class="header-anchor" href="#bash-内置的命令" aria-hidden="true">#</a> bash 内置的命令</h2><p>这些不是program，而是bash内建的命令。</p><ul><li>cd：改变目录</li><li>alias：给命令定义一个含义</li><li>source：执行一个脚本或批处理文件</li></ul><h2 id="目录操作" tabindex="-1"><a class="header-anchor" href="#目录操作" aria-hidden="true">#</a> 目录操作</h2><h3 id="linux-目录" tabindex="-1"><a class="header-anchor" href="#linux-目录" aria-hidden="true">#</a> Linux 目录</h3><p>我们知道Linux的目录结构为树状结构，最顶级的目录为根目录 <code>/</code></p><p>其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。</p><ul><li>**绝对路径：**路径的写法，由根目录 <strong>/</strong> 写起，例如： /usr/share/doc 这个目录。</li><li>**相对路径：**路径的写法，不是由 <strong>/</strong> 写起，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成： <strong>cd ../man</strong> 这就是相对路径的写法。</li></ul><h3 id="处理目录的常用命令" tabindex="-1"><a class="header-anchor" href="#处理目录的常用命令" aria-hidden="true">#</a> 处理目录的常用命令</h3><ul><li><p>ls（英文全拼：list files）: 列出目录及文件名</p><ul><li>-a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)</li><li>-d ：仅列出目录本身，而不是列出目录内的文件数据(常用)</li><li>-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)</li></ul></li><li><p>cd（英文全拼：change directory）：切换目录</p></li><li><p>pwd（英文全拼：print work directory）：显示目前的目录</p><ul><li><strong>-P</strong> ：显示出确实的路径，而非使用连结 (link) 路径。就是软连接指向的绝对目录</li></ul></li><li><p>mkdir（英文全拼：make directory）：创建一个新的目录</p><ul><li>-m ：配置文件的权限</li><li>-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！<br><code>mkdir -p test1/test2/test3/test4</code></li></ul></li><li><p>rmdir（英文全拼：remove directory）：删除一个空的目录</p><ul><li>**-p ：**从该目录起，一次删除多级空目录</li></ul></li><li><p>cp（英文全拼：copy file）: 复制文件或目录</p><ul><li><strong>-a：相当於 -pdr 的意思，至于 pdr 请参考下列说明；(常用)</strong></li><li>**-d：**若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；</li><li>**-f：**为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；</li><li>**-i：**若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)</li><li>**-l：**进行硬式连结(hard link)的连结档创建，而非复制文件本身；</li><li><strong>-p：连同文件的属性一起复制过去，而非使用默认属性(备份常用)；</strong></li><li><strong>-r：递归持续复制，用于目录的复制行为；(常用)</strong></li><li>**-s：**复制成为符号连结档 (symbolic link)，亦即『捷径』文件；</li><li>**-u：**若 destination 比 source 旧才升级 destination ！</li></ul></li><li><p>rm（英文全拼：remove）: 删除文件或目录</p><ul><li><strong>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；</strong></li><li>-i ：互动模式，在删除前会询问使用者是否动作</li><li><strong>-r ：递归删除啊！最常用在目录的删除了！</strong></li></ul></li><li><p>mv（英文全拼：move file）: 移动文件与目录，或修改文件与目录的名称</p><ul><li><strong>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</strong></li><li>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！</li><li>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)</li></ul></li></ul><h2 id="常用操作" tabindex="-1"><a class="header-anchor" href="#常用操作" aria-hidden="true">#</a> 常用操作</h2><ul><li>To tell who you are, type <strong>whoami</strong></li><li>Type <strong>history</strong> to see a list of recent commands</li><li>如果你想重新执行在历史记录中发现的前一条命令，请输入 !n，其中n是该命令的编号（n可能是一个大数字）。</li><li>要执行以ca开头的最新命令（如cat），请输入！ca。输入 !c 将执行以c开头的最新命令（也许是cc，也许是cd，也许是chmod，也许是cat或其他）。</li><li>To execute the last command, just type <strong>!!</strong></li><li>To avoid typing <strong>./hello</strong> to execute hello, 你可以在执行路径中包括当前目录。输入<code>PATH=&quot;$PATH:.&quot;</code>，将当前目录<code>&quot;. &quot;</code>追加到路径变量（PATH）中。</li><li>你可以使用<code> man [命令]</code> 来查看各个命令的使用文档，如 ：<code>man cp</code>。</li></ul><h2 id="通配符" tabindex="-1"><a class="header-anchor" href="#通配符" aria-hidden="true">#</a> 通配符</h2><p>你可以使用通配符来匹配文件名 <code>* 和 ？</code>。</p><ul><li>例如，<code>ls lab*</code>会给你所有名字以<code>lab</code>开头的文件。</li><li>例如，<code>ls lab?</code> 会给你所有名字为<code>labx</code>的文件（<code>x</code>是一个字符）。</li></ul><p>你可以使用范围规范（[]和{}）。</p><p>例如</p><ul><li><code>ls lab[1-5].c</code> 将返回所有文件<code>labx.c</code>，其中 <code>x</code> 是1、2、3、4或5</li><li><code>ls lab[24].c</code> 将只返回<code>lab2.c</code>和<code>lab4.c</code>。 <ul><li>这里<code>[ ]</code>表示集合中的任何字符</li><li>如果你想获得文件<code>lab4.c、lab8.c和lab12.c</code>，你不能使用<code>[]</code>，因为它表示<strong>一个数字</strong>。 <ul><li>你必须使用<code>ls lab{4,8,12}.c</code>来代替，其中<code>{}</code>表示任何<strong>一个模式</strong>。</li></ul></li></ul></li></ul><p>在使用<code>ls</code>命令时，你可以使用通配符来匹配当前或选定目录中的文件。</p><img src="https://pic.hanjiaming.com.cn/2022/05/01/e39b72f2917bc.png" alt="1651335455307.png" style="zoom:50%;"><h2 id="connecting-commands" tabindex="-1"><a class="header-anchor" href="#connecting-commands" aria-hidden="true">#</a> Connecting commands</h2><p>UNIX和Linux的一个非常强大和独特的功能是链接命令的能力。</p><p>一条链包含一连串的命令甚至是用户程序。</p><p><code>prog1 | prog2 | prog3 | … | progn</code></p><p>程序1的输出是程序2的输入，以此类推。符号 &quot;|&quot; 在Unix/Linux中称为pipe。即使用pipe进行通信。</p><p>比如说</p><ul><li><code>ls | wc</code>将计算一个包含<code>ls</code>所有输出的文件的行数、字数和字符数。</li><li><code>ls | wc | lpr</code>将把上述输出发送到打印机（<code>lpr</code>是用打印机打印的命令）。</li></ul><h2 id="其他操作" tabindex="-1"><a class="header-anchor" href="#其他操作" aria-hidden="true">#</a> 其他操作</h2><h3 id="file" tabindex="-1"><a class="header-anchor" href="#file" aria-hidden="true">#</a> file</h3><p>特殊命令 <code>file</code>将让你知道一个文件（或一连串文件）的类型和其他信息。</p><img src="https://pic.hanjiaming.com.cn/2022/05/01/6ccfda824e353.png" alt="1651335610918.png" style="zoom:33%;"><img src="https://pic.hanjiaming.com.cn/2022/05/01/c5371e1585645.png" alt="1651335654492.png" style="zoom:50%;"><h3 id="grep" tabindex="-1"><a class="header-anchor" href="#grep" aria-hidden="true">#</a> grep</h3><p>如果你想在<strong>一个文件集合</strong>中寻找一个特定的字符串，你需要使用<code>grep</code>命令。这在Unix/Linux系统中是一个非常有用的命令。可以根据模式进行匹配。模式是正则表达式，由一些基元构建。</p><ul><li><code>^</code> means beginning of line;</li><li><code>$</code> means end of line;</li><li><code>.</code> means any character;</li><li><code>[abc]</code> means any one of a, b, c</li><li><code>[^abc]</code> means anything except a, b, c</li><li>use <code>\\</code> for escape 「换行」.</li></ul><p>比如</p><ul><li><p><code>grep malloc *.c</code> : Find C programs containing malloc and its usage<br><img src="https://pic.hanjiaming.com.cn/2022/05/01/89593012c8f92.png" alt="1651336775562.png" style="zoom:50%;"></p></li><li><p><code>grep -i polyu *.txt</code> : Find text files and lines containing PolyU <strong>(ignore upper/lower case)</strong>.</p></li><li><p><code>grep -l -i ’^polyu’ *.txt</code> : Print only the names of files with lines beginning with “polyu”.</p></li><li><p><code>grep –h ’poly[^u]’ *.txt</code>: Look for <code>poly”</code> except for “polyu” without filename</p><img src="https://pic.hanjiaming.com.cn/2022/05/01/0b41b60a775cb.png" alt="1651337086308.png" style="zoom:50%;"></li></ul>',44),a=[n];function d(r,t){return i(),o("div",null,a)}const h=e(c,[["render",d],["__file","basic.html.vue"]]);export{h as default};
