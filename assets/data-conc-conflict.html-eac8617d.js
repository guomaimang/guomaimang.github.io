const e=JSON.parse('{"key":"v-8847f4b6","path":"/note/it/arch/data-conc-conflict.html","title":"数据库并发冲突及解决方案","lang":"zh-CN","frontmatter":{"article":false,"date":"2024-12-23T00:00:00.000Z","index":true,"order":17,"headerDepth":1,"category":["tech"],"description":"数据库并发冲突及解决方案 在高并发场景下，多个线程对同一个账户进行并发更新时，可能会产生数据不一致的问题。具体场景如下： 两个线程获取同一个账户的余额。 线程一和线程二分别在账户上增加金额。 线程一和线程二分别将增加后的金额更新回数据库。 如果两个线程并发执行上述操作，会导致数据不一致。例如：","head":[["meta",{"property":"og:url","content":"https://guomaimang.github.io/note/it/arch/data-conc-conflict.html"}],["meta",{"property":"og:site_name","content":"HAN Jiaming | Hirsun | 韩佳明"}],["meta",{"property":"og:title","content":"数据库并发冲突及解决方案"}],["meta",{"property":"og:description","content":"数据库并发冲突及解决方案 在高并发场景下，多个线程对同一个账户进行并发更新时，可能会产生数据不一致的问题。具体场景如下： 两个线程获取同一个账户的余额。 线程一和线程二分别在账户上增加金额。 线程一和线程二分别将增加后的金额更新回数据库。 如果两个线程并发执行上述操作，会导致数据不一致。例如："}],["meta",{"property":"og:type","content":"website"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-27T18:33:55.000Z"}],["meta",{"property":"article:author","content":"Hirsun (HAN Jiaming)"}],["meta",{"property":"article:published_time","content":"2024-12-23T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-27T18:33:55.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"WebPage\\",\\"name\\":\\"数据库并发冲突及解决方案\\",\\"description\\":\\"数据库并发冲突及解决方案 在高并发场景下，多个线程对同一个账户进行并发更新时，可能会产生数据不一致的问题。具体场景如下： 两个线程获取同一个账户的余额。 线程一和线程二分别在账户上增加金额。 线程一和线程二分别将增加后的金额更新回数据库。 如果两个线程并发执行上述操作，会导致数据不一致。例如：\\"}"]]},"headers":[{"level":2,"title":"传统解决方案：悲观锁","slug":"传统解决方案-悲观锁","link":"#传统解决方案-悲观锁","children":[{"level":3,"title":"悲观锁的实现","slug":"悲观锁的实现","link":"#悲观锁的实现","children":[]},{"level":3,"title":"悲观锁的执行流程","slug":"悲观锁的执行流程","link":"#悲观锁的执行流程","children":[]},{"level":3,"title":"悲观锁的缺点","slug":"悲观锁的缺点","link":"#悲观锁的缺点","children":[]}]},{"level":2,"title":"现代解决方案：乐观锁","slug":"现代解决方案-乐观锁","link":"#现代解决方案-乐观锁","children":[{"level":3,"title":"乐观锁的实现","slug":"乐观锁的实现","link":"#乐观锁的实现","children":[]},{"level":3,"title":"乐观锁的执行流程","slug":"乐观锁的执行流程","link":"#乐观锁的执行流程","children":[]},{"level":3,"title":"乐观锁的优点","slug":"乐观锁的优点","link":"#乐观锁的优点","children":[]},{"level":3,"title":"乐观锁的缺点","slug":"乐观锁的缺点","link":"#乐观锁的缺点","children":[]}]},{"level":2,"title":"具体实现","slug":"具体实现","link":"#具体实现","children":[{"level":3,"title":"数据表结构","slug":"数据表结构","link":"#数据表结构","children":[]},{"level":3,"title":"伪代码示例","slug":"伪代码示例","link":"#伪代码示例","children":[]},{"level":3,"title":"处理并发冲突","slug":"处理并发冲突","link":"#处理并发冲突","children":[]},{"level":3,"title":"Spring Retry 组件使用","slug":"spring-retry-组件使用","link":"#spring-retry-组件使用","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1735324435000,"updatedTime":1735324435000,"contributors":[{"name":"hanjiaming","email":"47519540+guomaimang@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":9.94,"words":994},"filePathRelative":"note/it/arch/data-conc-conflict.md","localizedDate":"2024年12月23日","excerpt":"<h1> 数据库并发冲突及解决方案</h1>\\n<p>在高并发场景下，多个线程对同一个账户进行并发更新时，可能会产生数据不一致的问题。具体场景如下：</p>\\n<img src=\\"https://pic.hanjiaming.com.cn/2024/12/27/2a9b51802941c.png\\" alt=\\"1735287906978.png\\" style=\\"zoom:25%;\\">\\n<ol>\\n<li>两个线程获取同一个账户的余额。</li>\\n<li>线程一和线程二分别在账户上增加金额。</li>\\n<li>线程一和线程二分别将增加后的金额更新回数据库。</li>\\n</ol>\\n<p>如果两个线程并发执行上述操作，会导致数据不一致。例如：</p>","autoDesc":true}');export{e as data};
