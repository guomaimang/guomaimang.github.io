import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o as r,c,a as i,b as l,d as e,e as p}from"./app-3e4b528e.js";const o={},h=p(`<h1 id="components-interconnects" tabindex="-1"><a class="header-anchor" href="#components-interconnects" aria-hidden="true">#</a> Components &amp; Interconnects</h1><h2 id="计算机组件" tabindex="-1"><a class="header-anchor" href="#计算机组件" aria-hidden="true">#</a> 计算机组件</h2><p>计算机主要是由以下三部分组成</p><ul><li>中央处理器（CPU） <ul><li>CPU =控制单元（CU）+算术和逻辑单元（ALU）</li><li>两个功能：控制和计算</li></ul></li><li>IO <ul><li>因为数据和指令需要进入系统</li><li>并且我们需要输出结果</li></ul></li><li>主存（Main Memory） <ul><li>需要临时存储代码（程序）和结果</li></ul></li></ul><figure><img src="https://pic.hanjiaming.com.cn/2021/01/20210120133231361.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="寄存器-register-存储信息的地方" tabindex="-1"><a class="header-anchor" href="#寄存器-register-存储信息的地方" aria-hidden="true">#</a> 寄存器（Register）：存储信息的地方</h2><ul><li>程序计数器（PC）：也称为指令地址寄存器；它存储将要执行的下一条指令的内存地址；在获取指令后它将增加</li><li>指令寄存器（IR）：保存当前正在执行的指令</li><li>内存地址寄存器（MAR）：它存储将从中将数据提取到CPU的内存地址或将数据发送到的内存地址</li><li>内存缓冲寄存器（MBR）：它存储与即时访问存储器之间传输的数据</li></ul><h2 id="指令-instruction" tabindex="-1"><a class="header-anchor" href="#指令-instruction" aria-hidden="true">#</a> 指令（Instruction）</h2><ul><li>指令是由CPU完成的算术或逻辑运算 <ul><li>ADD：将两个数字加在一起</li><li>COMPARE：比较数字</li><li>JUMP：跳转到RAM地址</li><li>LOAD：将信息从RAM加载到CPU</li></ul></li><li>指令集是计算机支持的指令集 <ul><li>取决于硬件–不同的体系结构将支持不同的指令集</li></ul></li></ul><h2 id="程序-program-是什么" tabindex="-1"><a class="header-anchor" href="#程序-program-是什么" aria-hidden="true">#</a> 程序（Program）是什么</h2><p>程序：一系列指令</p><ul><li>不能使用C，Java，Python等高级语言编写程序语句，但可以把他们翻译成程序语句</li><li>每个程序语句将转换为一系列指令</li><li>例如：IN，ADD，JUMP，LOAD，OUT</li><li>旨在实现一定功能</li></ul><p>机器语言编写程序不仅难读,难写而且非常不灵活.</p><h3 id="用汇编语言开发程序" tabindex="-1"><a class="header-anchor" href="#用汇编语言开发程序" aria-hidden="true">#</a> 用汇编语言开发程序</h3><p>若用符号表示跳转位置和变量位置，是否简化了问题？</p><p>于是，汇编语言出现：用助记符表示操作码，用标号表示位置，用助记符表示寄存器</p><figure><img src="https://pic.hanjiaming.com.cn/2021/01/20210120145327752.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>用汇编语言编写的优点是： 不会因为增减指令而需要修改其他指令 不需记忆指令编码，编写方便 可读性比机器语言强。不过，这带来新的问题，是什么呢？人容易了，可机器不认识这些指令了.所以，我们需将汇编语言转 换为机器语言！ 我们用汇编程序作为中介进行转换</p><p>但是，我们进一步认识汇编语言，会发现汇编语言(源)程序由汇编指令构成</p><ul><li>什么是汇编指令？ <ul><li>用助记符和标号来表示的指令（与机器指令一一对应）</li></ul></li><li>指令又是什么呢？ <ul><li>包含操作码和操作数或其地址码 <ul><li>机器指令用二进制表示</li><li>汇编指令用符号表示</li></ul></li><li>只能表达这些：取（或存一个数）、两个数加（或减、乘、除、与、或等）、根据运算结果判断是否转移执行</li></ul></li></ul><p>想象用汇编语言编写复杂程序是怎样的情形？ （例如，用汇编语言实现排序（sort）、矩阵相乘） 需要描述的细节太多了！程序会很长很长！而且在不同 结构的机器上就不能运行！</p><p>机器语言和汇编 语言都是面向机 器结构的语言， 故它们统称为机 器级语言</p><p>结论：用汇编语言比机器语言好，但是，还是很麻烦！</p><h3 id="高级编程语言" tabindex="-1"><a class="header-anchor" href="#高级编程语言" aria-hidden="true">#</a> 高级编程语言</h3><ul><li>它们与具体机器结构无关</li><li>面向算法描述，比机器级语言描述能力强得多</li><li>高级语言中一条语句对应几条、几十条甚至几百条指令</li><li>有“面向过程”和“面向对象”的语言之分</li><li>处理逻辑分为三种结构 • 顺序结构、选择结构、循环结构</li><li>有两种转换方式：“编译”和“解释” <ul><li>编译程序(Complier)：将高级语言源程序转换为机器级目 标程序，执行时只要启动目标程序即可</li><li>解释程序(Interpreter )：将高级语言语句逐条翻译成机器 指令并立即执行，不生成目标文件</li></ul></li></ul><h3 id="经典案例-hello-world的编写" tabindex="-1"><a class="header-anchor" href="#经典案例-hello-world的编写" aria-hidden="true">#</a> 经典案例：Hello，world的编写</h3><p>我们用C++ 一个简单的程序</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>#include &lt;stdio.h&gt;
int main()
{
printf(hello, world\\n);
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://pic.hanjiaming.com.cn/2021/01/20210120150327166.png" alt="" loading="lazy"><img src="https://pic.hanjiaming.com.cn/2021/01/20210120150406829.png" alt="" loading="lazy"></p><figure><img src="https://pic.hanjiaming.com.cn/2021/01/20210120150426458.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>数据经常在各存储部件间传送。故现代计算机大多采用“缓存”技术<br> 所有过程都是在CPU执行指令所产生的控制信号的作用下进行的</p><figure><img src="https://pic.hanjiaming.com.cn/2021/01/20210120150640628.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://pic.hanjiaming.com.cn/2021/01/20210122050908628.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="指令周期-instruction-cycle" tabindex="-1"><a class="header-anchor" href="#指令周期-instruction-cycle" aria-hidden="true">#</a> 指令周期（Instruction Cycle）</h2><p>两个主要步骤：取、执行<br><strong>指令周期（Instruction Cycle） = 提取周期（Fetch Cycle）+ 执行周期（Execute Cycle）</strong>, 可能会有中中断周期</p><figure><img src="https://pic.hanjiaming.com.cn/2021/01/20210120134928829.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>所有步骤均由控制单元使用内置时钟（周期）控制：synchronization<br> 因此，一条指令通常消耗一个以上的时钟周期（步骤和顺序的调节器）</p><h2 id="提取周期-fetch-cycle-中的动作" tabindex="-1"><a class="header-anchor" href="#提取周期-fetch-cycle-中的动作" aria-hidden="true">#</a> 提取周期（Fetch Cycle）中的动作</h2><ul><li>程序计数器（PC）已保存要提取的下一条指令的地址 <ul><li>指令顺序执行</li></ul></li><li>处理器从PC指向的内存位置获取指令（需要先将地址放入MAR）</li><li>指令加载到指令寄存器（IR）中（需要先将指令放入MBR）</li><li>PC计数器增量（顺序执行） <ul><li>除非在执行周期中另有说明（例如，从IF-THEN-ELSE，循环语句）</li></ul></li><li>处理器解释指令并准备执行所需的操作</li></ul><h2 id="执行周期-execute-cycle-中的动作" tabindex="-1"><a class="header-anchor" href="#执行周期-execute-cycle-中的动作" aria-hidden="true">#</a> 执行周期（Execute Cycle）中的动作</h2><p>取决于指令</p><ul><li>处理器-内存 <ul><li>CPU和主存储器之间的数据传输</li></ul></li><li>处理器-I / O <ul><li>CPU和I / O模块之间的数据传输</li></ul></li><li>数据处理 <ul><li>对数据进行一些算术或逻辑运算（ALU运算）</li></ul></li><li>控制 <ul><li>操作顺序的变更，例如分支和跳转（来自循环，函数调用等语句）</li></ul></li><li>以上组合</li></ul><h2 id="程序执行示例" tabindex="-1"><a class="header-anchor" href="#程序执行示例" aria-hidden="true">#</a> 程序执行示例</h2><p>最初：PC：300指令是IR中的第一位</p><figure><img src="https://pic.hanjiaming.com.cn/2021/01/20210120140002851.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol><li><p>首先，程序计数器（也称为指令地址寄存器/PC）中记录了内存中下一条应该执行的指令地址为300</p></li><li><p>之后，IR获取了地址为在内存中地址为300的程序指令1940（虽然我们不知道1940代表的指令是什么意思,我们假设它代表的意思为获取内存地址为940的值，故AC此时编程0003）</p></li><li><p>同时，PC更新为下一个内存地址301。</p></li><li><p>之后，IR获取了地址为在内存中地址为301的程序指令5941，（虽然我们不知道5941代表的指令是什么意思,我们假设它代表的意思为把内存地址为941的值和当前的值进行加和并存储到AC中，故AC此时编程0005）</p></li><li><p>同时，PC更新为下一个内存地址302.</p></li><li><p>之后，IR获取了地址为在内存中地址为302的程序指令2941（虽然我们不知道2941代表的指令是什么意思,我们假设它代表的意思为把当前AC的值存储到内存地址为941的地方，故AC此时编程0003）</p></li><li><p>同时，PC更新为下一个内存地址303.</p></li><li><p>......</p></li></ol><p>用图来看是这样的</p><figure><img src="https://pic.hanjiaming.com.cn/2021/01/20210120142135741.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="中断-interrupts" tabindex="-1"><a class="header-anchor" href="#中断-interrupts" aria-hidden="true">#</a> 中断（Interrupts）</h2><p>中断：其他模块（例如I / O）可以中断正常处理顺序的机制<br> 问题：想象一下，如果你在通话中并接到另一个来电，该怎么办？</p><p>也许我会考虑这另一个来电是否重要，重要的话，我会接听。不重要的话，我会等当前的电话打完后再处理另一个，即判断是否有接听的必要</p><p>中断源</p><ul><li>程序，例如溢出，除以零</li><li>计时器，例如由内部处理器计时器生成</li><li>I / O，例如从I / O控制器</li><li>硬件故障，例如内存奇偶校验错误</li></ul><h2 id="通过中断转移控制-transfer-of-control-via-interrupts" tabindex="-1"><a class="header-anchor" href="#通过中断转移控制-transfer-of-control-via-interrupts" aria-hidden="true">#</a> 通过中断转移控制（Transfer of Control via Interrupts）</h2><p>如果发生中断：</p><ol><li>处理器暂停当前程序的执行并保存其上下文</li><li>将PC设置为中断处理程序的起始地址</li></ol><figure><img src="https://pic.hanjiaming.com.cn/2021/01/20210120142819666.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="中断周期-interrupt-cycle" tabindex="-1"><a class="header-anchor" href="#中断周期-interrupt-cycle" aria-hidden="true">#</a> 中断周期（Interrupt Cycle）</h2><p>中断可能不可避免，所以，我们需要制定相关流程</p><ol><li>处理器检查中断</li><li>由中断信号指示</li><li>如果没有中断，则获取下一条指令</li><li>如果中断待处理：</li><li>暂停当前程序的执行</li><li>保存上下文</li><li>将PC设置为中断处理程序例程的起始地址</li><li>处理中断</li><li>恢复上下文并继续中断的程序</li></ol><h2 id="带中断的指令周期-instruction-cycle-with-interrupts" tabindex="-1"><a class="header-anchor" href="#带中断的指令周期-instruction-cycle-with-interrupts" aria-hidden="true">#</a> 带中断的指令周期（Instruction Cycle with Interrupts）</h2><figure><img src="https://pic.hanjiaming.com.cn/2021/01/20210120143145203.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>图解</p><figure><img src="https://pic.hanjiaming.com.cn/2021/01/20210120143159965.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>程序流程控制（Program Flow Control）</p><figure><img src="https://pic.hanjiaming.com.cn/2021/01/20210120143402104.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="多次中断-multiple-interrupts" tabindex="-1"><a class="header-anchor" href="#多次中断-multiple-interrupts" aria-hidden="true">#</a> 多次中断（Multiple Interrupts）</h2><p>无需了解详细信息，仅供参考</p><p>多个中断：当前正在处理中断时出现中断</p><ul><li>解决方案1：顺序处理：中断按顺序发生 <ul><li>处理器在处理一个中断时将忽略其他中断</li><li>中断保持挂起状态，并在处理完第一个中断后进行检查</li></ul></li></ul><figure><img src="https://pic.hanjiaming.com.cn/2021/01/20210120143608529.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>解决方案2：嵌套处理：允许中断期间的中断</p><figure><img src="https://pic.hanjiaming.com.cn/2021/01/20210120143632653.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>问题：两种方法有什么区别？</p><ul><li>如何处理？ 设置公正和紧急的优先事项</li><li>低优先级中断可以被高优先级中断打断</li><li>处理较高优先级的中断后，处理器将返回上一个中断</li></ul><h2 id="连接计算机组件-互连" tabindex="-1"><a class="header-anchor" href="#连接计算机组件-互连" aria-hidden="true">#</a> 连接计算机组件（互连）</h2><p>所有单元必须连接</p><p>不同类型的单元有不同类型的连接</p><ul><li>Memory</li><li>Input/Output</li><li>CPU</li></ul><h2 id="电脑模块-组件" tabindex="-1"><a class="header-anchor" href="#电脑模块-组件" aria-hidden="true">#</a> 电脑模块/组件</h2><p>所有三个组件均通过bus(es)进行通信,如下图</p><p><img src="https://pic.hanjiaming.com.cn/2021/01/20210120144002302.png" alt="" loading="lazy">## Bus</p><h2 id="interconnection-scheme-了解即可" tabindex="-1"><a class="header-anchor" href="#interconnection-scheme-了解即可" aria-hidden="true">#</a> Interconnection Scheme （了解即可）</h2><figure><img src="https://pic.hanjiaming.com.cn/2021/01/20210120144147303.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="bus-总线-是什么" tabindex="-1"><a class="header-anchor" href="#bus-总线-是什么" aria-hidden="true">#</a> BUS(总线) 是什么</h2><ul><li><p>连接两个或更多设备的通信路径</p><ul><li>通常广播，经常分组 <ul><li>一条总线中的多个通道，例如32位数据总线是32个独立的单个位通道</li></ul></li></ul></li><li><p>三种总线类别：数据总线，地址总线和控制总线</p></li><li><p>单总线与多总线结构</p><ul><li>例如Unibus（DEC-PDP）</li><li>例如控制/地址/数据总线（PC）</li></ul></li><li><p>专用总线</p><ul><li>分配给单个功能，例如用于地址或数据的功能，称为地址总线和数据总线</li><li>不同组件的分离总线</li></ul></li><li><p>多路总线</p><ul><li>用于地址和数据-共享线</li><li>优势：行数更少</li><li>缺点：更复杂的控制和资源的顺序使用将限制性能</li></ul></li></ul><h2 id="有关内容推荐" tabindex="-1"><a class="header-anchor" href="#有关内容推荐" aria-hidden="true">#</a> 有关内容推荐</h2>`,87),d={href:"https://www.doc.ic.ac.uk/~eedwards/compsys/index.html",target:"_blank",rel:"noopener noreferrer"},u=i("h2",{id:"引用材料",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#引用材料","aria-hidden":"true"},"#"),l(" 引用材料")],-1),s=i("li",null,"William Stallings, “Computer organization and architecture: Designing for Performance”, 8th Edition, 2010",-1),g=i("li",null,"Dr. Kai Zhou's PowerPoint",-1),f={href:"https://www.cnblogs.com/chenxuming/p/9609463.html",target:"_blank",rel:"noopener noreferrer"};function m(b,x){const a=t("ExternalLinkIcon");return r(),c("div",null,[h,i("ul",null,[i("li",null,[i("a",d,[l("https://www.doc.ic.ac.uk/~eedwards/compsys/index.html"),e(a)])])]),u,i("ul",null,[s,g,i("li",null,[i("a",f,[l("https://www.cnblogs.com/chenxuming/p/9609463.html"),e(a)])])])])}const P=n(o,[["render",m],["__file","module-function.html.vue"]]);export{P as default};
