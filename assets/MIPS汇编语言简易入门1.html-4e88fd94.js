import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{r as a,o as s,c as o,a as i,b as e,d as l,e as n}from"./app-a1c6ff48.js";const u={},d=n('<h1 id="mips汇编语言简易入门1" tabindex="-1"><a class="header-anchor" href="#mips汇编语言简易入门1" aria-hidden="true">#</a> MIPS汇编语言简易入门1</h1><blockquote><p>汇编语言（Assembly Language）是任何一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。在汇编语言中，用助记符代替机器指令的操作码，用地址符号或标号代替指令或操作数的地址。在不同的设备中，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。特定的汇编语言和特定的机器语言指令集是一一对应的，不同平台之间不可直接移植。</p><p>百科</p></blockquote><h2 id="为什么选择学习mips汇编语言" tabindex="-1"><a class="header-anchor" href="#为什么选择学习mips汇编语言" aria-hidden="true">#</a> 为什么选择学习MIPS汇编语言？</h2><p>MIPS (Microprocessor without Interlocked Pipeline Stages)</p><ul><li>过去非常流行：三分之一的RISC芯片基于MIPS</li><li>今天仍在使用：路由器、嵌入式系统、视频游戏机</li><li>学习MIPS对学习其他RISC汇编语言100%有帮助，比如ARM</li></ul><p>还有其他类型的汇编语言，比如Arm、intel_x86</p><p>本教程主要使用英文介绍MIPS-32bit</p><h2 id="学习依赖知识" tabindex="-1"><a class="header-anchor" href="#学习依赖知识" aria-hidden="true">#</a> 学习依赖知识</h2><p>在学习本文之前，你可能要先学习我的这几篇文章。</p><ul><li>计算机组织简介</li><li>数位系统以及其算法1</li><li>\bC &amp; C++中的常见的运算符和运算操作</li></ul><p>高级语言常常被转换成汇编语言。</p><figure><img src="https://pic.hanjiaming.com.cn/2021/02/20210201070359426.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>汇编语言将会被转换为机器语言</p><figure><img src="https://pic.hanjiaming.com.cn/2021/02/20210201070136689.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h2 id="产生可执行文件" tabindex="-1"><a class="header-anchor" href="#产生可执行文件" aria-hidden="true">#</a> 产生可执行文件</h2><figure><img src="https://pic.hanjiaming.com.cn/2021/02/20210201070322967.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li>程序（program）通常包含几个模块。</li><li>模块（module）通常包含对其他模块的引用（以使用数据或子例程）。</li><li>链接（linker）：组合独立组装的目标文件并解析引用</li></ul><h2 id="汇编语言的作用" tabindex="-1"><a class="header-anchor" href="#汇编语言的作用" aria-hidden="true">#</a> 汇编语言的作用</h2><p>首先，使用编译器将高级语言转换为汇编语言（在某些情况下）<br> 第二，直接用作编写程序的语言，它具有独特的优势</p><figure><img src="https://pic.hanjiaming.com.cn/2021/02/20210201070502906.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><figure><img src="https://pic.hanjiaming.com.cn/2021/02/20210201070631197.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h2 id="优缺点" tabindex="-1"><a class="header-anchor" href="#优缺点" aria-hidden="true">#</a> 优缺点</h2><p>主要优点</p><ul><li>速度快，存储空间小，不需要编译器</li><li>可以利用高级语言不具备的某些硬件功能。</li><li>什么时候使用？当对速度，尺寸，性能等有严格要求时… <ul><li>示例：设计汽车制动器的控制单元</li></ul></li></ul><p>主要缺点</p><ul><li>特定于机器的：必须完全重写才能在另一台计算机体系结构上运行</li><li>比高级语言更长的时间-耗时且漏洞多</li><li>很难写</li></ul><h2 id="功能特点" tabindex="-1"><a class="header-anchor" href="#功能特点" aria-hidden="true">#</a> 功能特点</h2><ul><li><p>基于寄存器的架构</p><ul><li>CPU对寄存器执行操作</li><li>操作可以分为两类： <ul><li>内存访问（在内存和寄存器之间加载和存储数据）</li><li>ALU操作（寄存器之间的操作）</li></ul></li></ul></li><li><p>精简指令集计算机（RISC）</p><ul><li>只有一小部分简单的说明</li><li>在此集合上建立更复杂的功能</li><li>与复杂指令集计算机（CISC）不同，在复杂指令集计算机（CISC）中，一条指令可能对应于复杂操作</li><li>两种不同的设计理念</li></ul></li><li><p>关键点</p><ul><li>寄存器 （Registers）</li><li>主内存（知道要访问的地址）</li><li>指示</li></ul></li><li><p>MIPS汇编语言：如何使用指令实现某些功能在寄存器（和存储器）之间进行操作</p></li></ul><hr><h2 id="预备知识" tabindex="-1"><a class="header-anchor" href="#预备知识" aria-hidden="true">#</a> 预备知识</h2><h3 id="栈的理解" tabindex="-1"><a class="header-anchor" href="#栈的理解" aria-hidden="true">#</a> 栈的理解</h3><p>栈某种意义上讲，它像是一个开口的盒子，先放进去的东西总是会被后放进去的东西压在下面，那么如果想拿出被压住的东西，必须要先取出顶部的东西，也就是后放进去的东西。换个说法就是先入后出。那它有点像什么呢?想象一下装在盘子里的若干张油饼。</p><p>对，他们是摞在一起的。如果想拿下面的油饼是不是要先拿开上面的呢?或许，这就是栈的根源。但是，又和“栈”这个字有什么关系呢?单纯的从释义上看，好似找不出什么关联性。但是当我们打开汉英词典：</p><p>对计算机中提及的“栈”的英文愿意是stack!我们一定要记得，是一群说英语的人创造了计算机，也是他们研究了初的算法。那么stack又是什么意思?</p><p>注意箭头指向的那一摞书们，和饼们的相处方式是不是很像!堆叠到一起。那个根源出来了，其实栈就是一种将数据依次“堆叠”的一种数据组织方式。</p><h3 id="位拓展" tabindex="-1"><a class="header-anchor" href="#位拓展" aria-hidden="true">#</a> 位拓展</h3><p>First digital extention：1101 0111 -&gt; 1111 1111 1101 0111，0011 1001 -&gt; 0000 0000 0011 1001</p><p>Zero extention： 1101 0111 -&gt; 0000 0000 1101 0111</p><p>Immediate and const are lenth of 16bits,which need to be extended brfore they are saved in memory.</p><p>How to realize it?</p><img src="https://hongshupic.oss-cn-zhangjiakou.aliyuncs.com/2021/02/18/1d536ed6301da.png" alt="CleanShot 2021-02-18 at 10.58.22@2x.png" title="CleanShot 2021-02-18 at 10.58.22@2x.png"><h2 id="mips-registers" tabindex="-1"><a class="header-anchor" href="#mips-registers" aria-hidden="true">#</a> MIPS Registers</h2><ul><li>32 general-purpose registers <ul><li>each has 32 bits</li><li>some are reserved for special purposes</li><li>Naming: how to refer to these registers <ul><li>start with “$”</li><li>directly use register number: $0 through $31 (decimal)</li><li>they also have names: $t1, $sp (better to use names in assembly language)</li></ul></li></ul></li><li>Hi and Lo registers <ul><li>for multiplication and division <ul><li>e.g., with 32 bits numbers, multiplication and division result in 64 bits numbers</li></ul></li><li>not directly addressable; must use special instructions to access (mfhi — move from Hi, mflo — move from lo)</li></ul></li><li>栈的走向是从高地址到低地址</li></ul>',43),p=i("table",null,[i("thead",null,[i("tr",null,[i("th",null,[i("em",null,"Register"),e(),i("em",null,"Number"),e("寄存器编号")]),i("th",null,[i("em",null,"Alternative"),e(),i("em",null,"Name"),e("寄存器名")]),i("th",null,[i("em",null,"Description"),e("寄存器用途")])])]),i("tbody",null,[i("tr",null,[i("td",null,[i("em",null,"0")]),i("td",null,[i("em",null,"zero")]),i("td",null,[i("em",null,"the value 0"),e("永远返回零")])]),i("tr",null,[i("td",null,[i("em",null,"1")]),i("td",null,[i("em",null,"$at")]),i("td",null,[i("em",null,[e("("),i("strong",null,"a"),e("ssembler "),i("strong",null,"t"),e("emporary) reserved by the assembler")]),e("汇编保留寄存器（不可做其他用途）")])]),i("tr",null,[i("td",null,[i("em",null,"2-3")]),i("td",null,[i("em",null,"$v0 - $v1")]),i("td",null,[i("em",null,[e("("),i("strong",null,"v"),e("alues) from expression evaluation and function results")]),e("（"),i("strong",null,"V"),e("alue简写）存储表达式或者是函数的返回值")])]),i("tr",null,[i("td",null,[i("em",null,"4-7")]),i("td",null,[i("em",null,"$a0 - $a3")]),i("td",null,[i("em",null,[e("("),i("strong",null,"a"),e("rguments) First four parameters for subroutine.")]),e(),i("em",null,"Not preserved across procedure calls"),e("（"),i("strong",null,"A"),e("rgument简写）存储子程序的前4个参数，在子程序调用过程中释放")])]),i("tr",null,[i("td",null,[i("em",null,"8-15")]),i("td",null,[i("em",null,"$t0 - $t7")]),i("td",null,[i("em",null,[e("("),i("strong",null,"t"),e("emporaries) Caller saved if needed. Subroutines can use w/out saving.")]),e(),i("em",null,"Not preserved across procedure calls"),e("（"),i("strong",null,"T"),e("emp简写）临时变量，同上调用时不保存")])]),i("tr",null,[i("td",null,[i("em",null,"16-23")]),i("td",null,[i("em",null,"$s0 - $s7")]),i("td",null,[i("em",null,[e("("),i("strong",null,"s"),e("aved values) - Callee saved.")]),e(),i("em",null,"A subroutine using one of these must save original and restore it before exiting."),e(),i("em",null,"Preserved across procedure calls"),e("（"),i("strong",null,"S"),e("aved or "),i("strong",null,"S"),e("tatic简写？）静态变量？调用时保存")])]),i("tr",null,[i("td",null,[i("em",null,"24-25")]),i("td",null,[i("em",null,"$t8 - $t9")]),i("td",null,[i("em",null,[e("("),i("strong",null,"t"),e("emporaries) Caller saved if needed. Subroutines can use w/out saving.")]),e(),i("em",null,"These are in addition to $t0 - $t7 above."),e(),i("em",null,"Not preserved across procedure calls."),e("（"),i("strong",null,"T"),e("emp简写）算是前面$0"),i("sub",null,"$7的一个继续，属性同$t0"),e("$t7")])]),i("tr",null,[i("td",null,[i("em",null,"26-27")]),i("td",null,[i("em",null,"$k0 - $k1")]),i("td",null,[i("em",null,"reserved for use by the interrupt/trap handler"),e("（brea"),i("strong",null,"K"),e(" off简写？）中断函数返回值，不可做其他用途")])]),i("tr",null,[i("td",null,[i("em",null,"28")]),i("td",null,[i("em",null,"$gp")]),i("td",null,[i("em",null,[i("strong",null,"g"),e("lobal "),i("strong",null,"p"),e("ointer.")]),e(),i("em",null,[e("Points to the middle of the 64K block of memory in the static data segment.**（"),i("strong",null,"G"),e("lobal "),i("strong",null,"P"),e("ointer简写）指向64k(2^16)大小的静态数据块的中间地址（字面上好像就是这个意思，块的中间）")])])]),i("tr",null,[i("td",null,[i("em",null,"29")]),i("td",null,[i("em",null,"$sp")]),i("td",null,[i("em",null,[i("strong",null,"s"),e("tack "),i("strong",null,"p"),e("ointer")]),e(" *Points to last location on the stack.**(*"),i("strong",null,"S"),e("tack "),i("strong",null,"P"),e("ointer简写）栈指针，指向的是栈顶")])]),i("tr",null,[i("td",null,[i("em",null,"30")]),i("td",null,[i("em",null,[i("span",{class:"katex"},[i("span",{class:"katex-mathml"},[i("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[i("semantics",null,[i("mrow",null,[i("mi",null,"s"),i("mn",null,"8"),i("mi",{mathvariant:"normal"},"/")]),i("annotation",{encoding:"application/x-tex"},"s8/")])])]),i("span",{class:"katex-html","aria-hidden":"true"},[i("span",{class:"base"},[i("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),i("span",{class:"mord mathnormal"},"s"),i("span",{class:"mord"},"8/")])])]),e("fp")])]),i("td",null,[i("em",null,[i("strong",null,"s"),e("aved value / "),i("strong",null,"f"),e("rame "),i("strong",null,"p"),e("ointer")]),e(),i("em",null,"Preserved across procedure calls"),e("("),i("strong",null,"S"),e("aved/"),i("strong",null,"F"),e("rame "),i("strong",null,"P"),e("ointer简写)帧指针")])]),i("tr",null,[i("td",null,[i("em",null,"31")]),i("td",null,[i("em",null,"$ra")]),i("td",null,[i("em",null,[i("strong",null,"r"),e("eturn "),i("strong",null,"a"),e("ddress")]),e("返回地址，目测也是不可做其他用途")])])])],-1),g=n(`<figure><img src="https://pic.hanjiaming.com.cn/2021/02/20210201090154664.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h2 id="other-mips-registers" tabindex="-1"><a class="header-anchor" href="#other-mips-registers" aria-hidden="true">#</a> Other MIPS Registers</h2><ul><li><p>Special registers</p><ul><li><p>e.g., PC</p></li><li><p>programmer cannot access with most instructions</p></li></ul></li><li><p>Hi and Lo registers</p><ul><li>for multiplication and division</li><li>e.g., with 32 bits numbers, multiplication and division result in 64 bits numbers</li><li>not directly addressable; must use special instructions to access (mfhi — move from Hi, mflo — move from lo)</li></ul></li></ul><hr><h2 id="mips内存布局" tabindex="-1"><a class="header-anchor" href="#mips内存布局" aria-hidden="true">#</a> MIPS内存布局</h2><p>MIPS内存布局:内存的组织方式 (MIPS Memory Layout — How is memory organized)</p><ul><li>用户程序只能使用一部分内存 <ul><li>从0x80000000到0x FFFFFFFF（顶部）用于操作系统和ROM</li></ul></li><li>可以用于用户程序的部分分为三个部分</li><li>文本，数据和堆栈段（Text Segment, Data Segment, and Stack Segment）</li></ul><figure><img src="https://pic.hanjiaming.com.cn/2021/02/20210201091353168.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li>Text segment：存储用户程序的机器语言（文本）</li><li>Data segment：存储程序运行的数据 <ul><li>静态数据（static data）：数据的大小是已知的，并且在由汇编程序分配时不会更改</li><li>动态数据（dynamic data）：在程序执行时分配和释放</li></ul></li><li>Stack Segment：用来存放局部变量和函数返回地址。随着过程的激活和停用，变量和参数被压入并弹出堆栈。</li></ul><p>注意：堆栈段向下增长，动态段向上增长</p><h3 id="一些关于内存的基本事实" tabindex="-1"><a class="header-anchor" href="#一些关于内存的基本事实" aria-hidden="true">#</a> 一些关于内存的基本事实</h3><p><strong>MIPS内存和地址</strong></p><ul><li><p>MIPS有32位和64位，大多数学习的是32位，我们也将讨论32位。</p></li><li><p>存储器中的基本“单位（units）”是 字节byte（8 位「bits比特」）</p><ul><li>bit比特值 可为0或1</li></ul></li><li><p>字节值 可为一个字节</p></li><li><p>8比特bit = 1字节byte，是因为8个bit可以表示一个byte</p></li><li><p>内存中总共有2 ^ {32}个字节；</p></li><li><p>每个字节的地址为32bits长；</p></li><li><p>地址范围：0x00000000至0x FFFFFFFF</p><ul><li>注：0x表示十六进制数</li><li>注：地址0x后面的每一个值都占一个字节，</li></ul></li></ul><p>32位=4字节，可表示4^16 = 2 ^32个不同的地址 。故地址是32位长。<br> 所以32位处理器也代表每个地址长度为32比特，64位处理器也代表每个地址长度为64比特。由此推断32bit处理器最大支持 2^32byte = 4GByte内存，64位处理器最大支持 2^64 = 2147483648GByte内存。</p><figure><img src="https://pic.hanjiaming.com.cn/2021/02/20210202091158498.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>操作方式</strong></p><ul><li>Operations（操作方式） <ul><li>load: copy a bit pattern (could be data or instruction) in a designated(特定的） address in memory to a register (memory -&gt; register)</li><li>store: copy a bit pattern from register to memory at a designated address (register -&gt; memory)</li></ul></li><li>内存通常以连续字节（一组字节）进行访问 <ul><li>one byte = 8 bits</li><li>one word = 4 bytes = 32bits(仅适用于MIPS)</li><li>double word = 8 bytes = 64bits (仅适用于MIPS)</li></ul></li><li>Memory is used to store instructions and data <ul><li>instruction has a fixed length of one word（指令的固定长度为一个字）</li></ul></li><li>data can have various bytes</li></ul><p>但是在x86_64中</p><ul><li>one byte = 8 bits</li><li>one word = 2 bytes(仅适用于x86_64)</li><li>double word = 4 bytes = 64 bits(仅适用于x86_64)</li></ul><figure><img src="https://pic.hanjiaming.com.cn/2021/02/20210204163743709.png" alt="此图像的alt属性为空；文件名为20210204163743709.png" tabindex="0" loading="lazy"><figcaption>此图像的alt属性为空；文件名为20210204163743709.png</figcaption></figure><p>对于连续的字节（一组字节），我们经常使用第一个字节的地址（即地址最低的字节），稍后会详细介绍</p><h2 id="mips-instructions-介绍" tabindex="-1"><a class="header-anchor" href="#mips-instructions-介绍" aria-hidden="true">#</a> MIPS Instructions 介绍</h2><ul><li>There are 3 types of instructions in MIPS <ul><li>R-type instructions</li><li>I-type instructions</li><li>J-type instructions</li></ul></li><li>each instruction has 32 bits（fixed）</li></ul><h3 id="r-type-instructions" tabindex="-1"><a class="header-anchor" href="#r-type-instructions" aria-hidden="true">#</a> R-type Instructions</h3><p><strong>Format</strong></p><ul><li><p>three arguments（参数）: two source registers（源寄存器） (<strong>rt</strong> and <strong>rs</strong>) and one destination register（目标寄存器） (<strong>rd</strong>)</p></li><li><p>written as instruction</p><p>rd, rs, rt</p><ul><li>example: <code>add $t0, $t1, $t2 </code>meaning that add the values in $t1 and $t2 and stores the result in $t0</li></ul></li></ul><p><strong>The machine code</strong></p><ul><li>“<strong>instruction rd, rs, rt</strong>” is a line of code in assembly language</li><li>need to translate it to machine language (binary) — assembler</li><li>the machine code has fixed format (32 bits)</li></ul><figure><img src="https://pic.hanjiaming.com.cn/2021/02/20210202160228473.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li><p><strong>op</strong> or <strong>opcode</strong>(operation code)：indicate the type of an instruction; all R-type instructions have opcode 000000</p></li><li><p>rs, rt, rd</p><p>：indicate which register</p><ul><li>length = 5bits <ul><li>5bits reason：there are 2^4 =32 general-purpose registers</li><li>example: rd = 01000 -&gt; register $8 = $t0</li></ul></li></ul></li><li><p><strong>shamt</strong>: used in shift instruction; how many positions (bits) to shift</p></li><li><p><strong>funct</strong>: indicate which instruction; e.g., 100000 -&gt; add</p></li></ul><p>举例：add</p><figure><img src="https://pic.hanjiaming.com.cn/2021/02/20210202160848827.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>举例：shift（移位）</p><figure><img src="https://pic.hanjiaming.com.cn/2021/02/20210202161043964.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="i-type-instructions" tabindex="-1"><a class="header-anchor" href="#i-type-instructions" aria-hidden="true">#</a> I-type Instructions</h3><p><strong>Format</strong></p><ul><li>three arguments: two registers (<strong>rt</strong> and <strong>rs</strong>) and a 16-bit “immediate” value</li><li>immediate value <ul><li>store the value directly within the instruction</li><li>could be a constant serving as one operand in the arithmetic operation ,or an address in load/store instructions</li></ul></li><li>assembly language: <strong>instruction</strong> <strong>rs, rt, imm</strong> (but not always)</li></ul><p><strong>Machine code</strong></p><ul><li>op: specify which instruction (different from R-type)</li></ul><figure><img src="https://pic.hanjiaming.com.cn/2021/02/20210202161622665.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>Example: bitwise OR operation (ori)</strong></p><ul><li><p>assembly language:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code> ori rs, rt, imm
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>operation: take the bit-wise OR between the value stored in rs and imm, then store the result in rt</li><li>example: ori $0, $8, 0x2 <ul><li>what is $0? : constant value 0</li><li>what is 0x2 —&gt; It means 2 in hexadecimal,but its essence is 0000 0000 0000 0000 0000 0000 0000 0010 in 32 bits.</li></ul></li></ul></li></ul><figure><img src="https://pic.hanjiaming.com.cn/2021/02/20210202164224390.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>Is there any problem for the bit-wise OR?<br> Yes! Value in $0 has 32 bits, imm has 16 bits; how can we do bit-wise OR?</p><ul><li>zero extension: MIPS will zero-extend the 16-bit operand imm to 31 bits, by padding with zeros on the left <ul><li>0000 0000 0000 0000 0000 0000 0000 0010 (0x2)</li><li>0000 0000 0000 0000 0000 0000 0000 0000 (value in $0)</li><li>0000 0000 0000 0000 0000 0000 0000 0010 (put in $8)</li></ul></li></ul><p>What’s the effect of ori (bit-wise OR)?<br> such as: loading the value stored in imm to the target register, by using the constant value in $0;<br> 举例：use ori to load decimal 17 into register $t1<br><code>ori $0 $t1 0xF1</code></p><p><strong>Example: load word (lw)</strong></p><ul><li><p>operation: load a word from memory at a designated address to a register</p></li><li><p>problem: we need to specify the memory address (32 bits) in the instruction (32 bits); how can we do that?</p><ul><li><p>the address of that memory has 32 bits,the length of instruction is 32-bit</p></li><li><p>solution: An instruction that refers to memory uses a <strong>base register</strong> and an <strong>offset</strong>. The base register is a general purpose register that contains a 32-bit address. The offset is a 16-bit signed integer contained in the instruction. The sum of the address in the base register with the (sign-extended) offset forms the memory address.</p></li><li><p>memory address = base address + offset</p></li><li><p>offset: a 16-bit signed constant (immediate value「立即数」)</p></li><li><p>basere (a name of the register to put data in) : the register containing the base address</p></li></ul></li><li><p>assembly language: <strong>lw, destreg, offset (basereg)</strong></p></li></ul><p><strong>Example: lw $8, 0x60 ($10)</strong></p><p>suppose $10 stores the value 0x00400000 (base address)<br> memory address = 0x00400060<br> load the word in the memory (0x00400060) to $8</p><figure><img src="https://pic.hanjiaming.com.cn/2021/02/20210202170315338.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>Example: store word (sw)</strong></p><ul><li>assembly language: <strong>sw, t, offset (basereg)</strong></li><li>operation: copy the data stored in register t to the memory at address ( base address in basereg + offset)</li><li>example: sw $12, 0x50 ($13)</li></ul><p><strong>Other data transfer instructions (not exhaustive) in I-type</strong></p><figure><img src="https://pic.hanjiaming.com.cn/2021/02/20210202173920386.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="j-type-instructions" tabindex="-1"><a class="header-anchor" href="#j-type-instructions" aria-hidden="true">#</a> J-type Instructions</h3><ul><li>Function: control the program flow to a given instruction</li><li>Format: <strong>instruction addr</strong></li></ul><p>Typical example: <strong>j addr</strong> (jump to the instruction at address addr / change the content of pc)</p><figure><img src="https://pic.hanjiaming.com.cn/2021/02/20210202174531959.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><figure><img src="https://pic.hanjiaming.com.cn/2021/02/20210202175302333.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>为什么Address总是相隔4个：一条指令在内存中占用4个字节，只索引第一个地址编码即可。所以我们使用最低字节的地址来指代连续字节。</p><p><strong>Machine code</strong></p><figure><img src="https://pic.hanjiaming.com.cn/2021/02/20210202174135128.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>Again, we have a problem: addr has 26 bits, the address of an instruction has 32 bits. How is this solved in MIPS? — we need a mechanism to transform the 26-bit address in the instruction to a 32-bit address.</p><ul><li><p>one instruction occupies 4 bytes in memory (recall that each byte in memory has an address)</p></li><li><p>we use the address of the lowest byte to refer to contiguous bytes</p><ul><li><p>restriction: the address of the lowest byte should be a multiple of 4</p></li><li><p>as a result, the right-most two bits in the address of an instruction are always 00</p></li><li><p>we still need 30 bits</p></li></ul></li><li><p>the left-most 4 bits in the address</p><ul><li>they are set as the left-most 4 bits of the content in PC <ul><li>why? do not jump too far away</li><li>so we only need 26bits</li></ul></li></ul></li></ul><p>the target address we want to jump to (how did we get it?)</p><figure><img src="https://pic.hanjiaming.com.cn/2021/02/20210202181541238.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><hr><h2 id="做题笔记" tabindex="-1"><a class="header-anchor" href="#做题笔记" aria-hidden="true">#</a> 做题笔记</h2><ol><li>ori指令可以将负整数的二进制补码表示形式放入寄存器吗？ 不能，因为负数的二进制补码拓展要在前面补1，但是ori 通常与$0结合使用，会导致前面补0.</li></ol><h2 id="相关网站和软件推荐" tabindex="-1"><a class="header-anchor" href="#相关网站和软件推荐" aria-hidden="true">#</a> 相关网站和软件推荐</h2>`,71),c={href:"https://chortle.ccsu.edu/assemblytutorial/",target:"_blank",rel:"noopener noreferrer"},h={href:"http://spimsimulator.sourceforge.net/",target:"_blank",rel:"noopener noreferrer"},m={href:"https://spim.app.zhongxueguan.cn/",target:"_blank",rel:"noopener noreferrer"},f={href:"https://godbolt.org/",target:"_blank",rel:"noopener noreferrer"},b={href:"https://phoenix.goucher.edu/~kelliher/f2009/cs220/mipsir.html",target:"_blank",rel:"noopener noreferrer"},y={href:"http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/ch05s07.html",target:"_blank",rel:"noopener noreferrer"},x=i("h2",{id:"引用",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#引用","aria-hidden":"true"},"#"),e(" 引用")],-1),w={href:"https://www.cnblogs.com/thoupin/p/4018455.html",target:"_blank",rel:"noopener noreferrer"},v={href:"https://blog.csdn.net/czh500/article/details/89947536",target:"_blank",rel:"noopener noreferrer"},_={href:"https://www.geeksforgeeks.org/bitwise-operators-in-c-cpp/",target:"_blank",rel:"noopener noreferrer"},$=i("li",null,"Dr. Kai,ZHOU's PowerPoint",-1),S={href:"https://chortle.ccsu.edu/assemblytutorial/",target:"_blank",rel:"noopener noreferrer"};function I(k,P){const t=a("ExternalLinkIcon");return s(),o("div",null,[d,p,g,i("ul",null,[i("li",null,[e("美国中央康涅狄格州立大学MIPS学习和联系："),i("a",c,[e("https://chortle.ccsu.edu/assemblytutorial/"),l(t)])]),i("li",null,[e("Qtspim，用于编辑MIPS文件："),i("a",h,[e("http://spimsimulator.sourceforge.net/"),l(t)])]),i("li",null,[e("MIPS文件在线运行器："),i("a",m,[e("https://spim.app.zhongxueguan.cn/"),l(t)])]),i("li",null,[e("Compiler-Explorer："),i("a",f,[e("https://godbolt.org/"),l(t)])]),i("li",null,[i("a",b,[e("https://phoenix.goucher.edu/~kelliher/f2009/cs220/mipsir.html"),l(t)])]),i("li",null,[i("a",y,[e("http://www.cs.uwm.edu/classes/cs315/Bacon/Lecture/HTML/ch05s07.html"),l(t)])])]),x,i("ul",null,[i("li",null,[i("a",w,[e("https://www.cnblogs.com/thoupin/p/4018455.html"),l(t)])]),i("li",null,[i("a",v,[e("https://blog.csdn.net/czh500/article/details/89947536"),l(t)])]),i("li",null,[i("a",_,[e("https://www.geeksforgeeks.org/bitwise-operators-in-c-cpp/"),l(t)])]),$,i("li",null,[e("美国中央康涅狄格州立大学，"),i("a",S,[e("https://chortle.ccsu.edu/assemblytutorial/"),l(t)])])])])}const j=r(u,[["render",I],["__file","MIPS汇编语言简易入门1.html.vue"]]);export{j as default};
