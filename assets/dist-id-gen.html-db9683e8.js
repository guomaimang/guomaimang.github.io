import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as l,e}from"./app-f3f8173e.js";const n={},r=e('<h1 id="数据库自增主键与的探讨" tabindex="-1"><a class="header-anchor" href="#数据库自增主键与的探讨" aria-hidden="true">#</a> 数据库自增主键与的探讨</h1><p>为什么大厂严禁使用数据库的自增主键来生成ID号。</p><ol><li>大表为什么不能使用自增主键？</li><li>UUID是好的替代方案吗？</li><li>Snowflake雪花算法是什么？</li></ol><h2 id="自增主键" tabindex="-1"><a class="header-anchor" href="#自增主键" aria-hidden="true">#</a> 自增主键</h2><p>自增主键（auto increment）是指在一个主键上设置auto increment，即自增序列。生成数据时，无需设置主键值，数据库会根据数字的顺序（1, 2, 3, 4...）依次自动生成主键。</p><p>自增主键的使用场景</p><ul><li>创意型公司或学校毕业设计中使用自增主键没有问题。</li><li>在大厂（如京东、阿里、腾讯）中，自增主键往往禁止使用。</li></ul><h2 id="在分布式数据环境中的问题" tabindex="-1"><a class="header-anchor" href="#在分布式数据环境中的问题" aria-hidden="true">#</a> 在分布式数据环境中的问题</h2><h3 id="资源浪费" tabindex="-1"><a class="header-anchor" href="#资源浪费" aria-hidden="true">#</a> 资源浪费</h3><ul><li>假设有三个数据库（表分片），分别包含0到1亿、1亿到2亿、2亿到3亿的数据。</li><li>构建数据库集群时，如何评估每个数据库最多容纳一亿数据？如果数据库能承载1.5亿数据，是否还能扩展？ <ul><li>答案是否定的，因为范围分片是固定的，无法动态扩展。</li></ul></li></ul><h3 id="尾部热点问题" tabindex="-1"><a class="header-anchor" href="#尾部热点问题" aria-hidden="true">#</a> 尾部热点问题</h3><img src="https://pic.hanjiaming.com.cn/2024/12/18/a8e7dc4eed96f.png" alt="1734529078311.png" style="zoom:33%;"><ul><li>范围分片会产生尾部热点问题：数据堆积到2.5亿时，所有新数据都插入到分片三，导致分片三的数据库压力极大，而前两个分片几乎没有压力。</li><li>测试结果显示，范围分片的写入效率比哈希分片低1.5倍以上。</li></ul><h2 id="uuid-替代自增主键" tabindex="-1"><a class="header-anchor" href="#uuid-替代自增主键" aria-hidden="true">#</a> UUID 替代自增主键</h2><p>使用 UUID 可以替代自增主键吗？不可以！</p><h3 id="uuid的特点" tabindex="-1"><a class="header-anchor" href="#uuid的特点" aria-hidden="true">#</a> UUID的特点</h3><ul><li>UUID 是根据当前计算机时间及各种特性生成的全球唯一的128位长字符串。</li><li>使用 UUID 是无序的，作为主键会涉及大量索引重排</li></ul><h3 id="uuid-作为主键的问题" tabindex="-1"><a class="header-anchor" href="#uuid-作为主键的问题" aria-hidden="true">#</a> UUID 作为主键的问题</h3><ul><li>UUID 长度为128位，相比整形或长整形浪费空间。</li><li>无序的 UUID 会导致大量的索引重排。</li></ul><figure><img src="https://pic.hanjiaming.com.cn/2024/12/18/f7b32f2550e14.png" alt="1734529247258.png" tabindex="0" loading="lazy"><figcaption>1734529247258.png</figcaption></figure><p>InnoDB引擎基于B+树结构有序紧密存储，中间插入数据必然会造成”页分裂“现象产生</p><div class="hint-container info"><p class="hint-container-title">索引重排</p><ul><li>MySQL的InnoDB引擎采用B+树存储数据，叶子节点按顺序排列。</li><li>顺序主键新增数据时，只需在B+树最后追加元素，影响范围小。</li><li>无序UUID新增数据时，需要在索引某个点上附加，导致后续节点重排，代价高。</li></ul></div><p>结论: UUID不适合用作主键的替代品。</p><h2 id="snowflake-雪花算法" tabindex="-1"><a class="header-anchor" href="#snowflake-雪花算法" aria-hidden="true">#</a> Snowflake 雪花算法</h2><p>Snowflake是Twitter开发的分布式ID生成算法。</p><ul><li>主要思路：以时间为依据，结合机器ID和序列生成定长数字，作为新主键。</li><li>生成的序列是有序的</li></ul><h3 id="snowflake-算法的组成部分" tabindex="-1"><a class="header-anchor" href="#snowflake-算法的组成部分" aria-hidden="true">#</a> Snowflake 算法的组成部分</h3><figure><img src="https://pic.hanjiaming.com.cn/2024/12/23/8a68ec18daa58.png" alt="1734897391953.png" tabindex="0" loading="lazy"><figcaption>1734897391953.png</figcaption></figure><ol><li><strong>符号位</strong>：最高位，无实际用处，兼容长整形格式。</li><li><strong>时间戳</strong>：41位，表示本地毫秒级时间。</li><li><strong>机器ID</strong>：10位，表示数据库机器的特征，允许1024个数据库节点。</li><li><strong>序列</strong>：12位，在一毫秒内某数据库节点能生成的ID数量，最多4096个。</li></ol><h3 id="snowflake-算法的优点" tabindex="-1"><a class="header-anchor" href="#snowflake-算法的优点" aria-hidden="true">#</a> Snowflake 算法的优点</h3><ul><li>保证有序性和分布式环境下的唯一性。</li><li>每毫秒可生成416万个ID，足够大多数应用。</li></ul><div class="hint-container warning"><p class="hint-container-title">使用注意事项</p><p><strong>时间回拨问题</strong>：如果服务器时间回调几毫秒或前调几秒，可能会导致ID重复。</p><ul><li>时间回拨通常由人为调时间或服务器时钟同步引起。</li><li>真实环境下，时间回拨几乎不会发生。</li></ul></div><h3 id="实践中的应用" tabindex="-1"><a class="header-anchor" href="#实践中的应用" aria-hidden="true">#</a> 实践中的应用</h3><ul><li>Java 中已有许多线程安全的实现，调用相关库即可生成 ID。</li><li>后续会讲解 Snowflake 在 Sharding-JDBC 中的应用。</li></ul><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><ul><li>自增主键在分布式环境下有资源浪费和尾部热点问题。</li><li>UUID不适合作为主键替代品，会导致索引重排。</li><li>Snowflake 算法能生成有序且唯一的分布式ID，是较好的解决方案。</li><li>关注时间回拨问题，但在大多数场景下Snowflake是可靠的。</li></ul>',36),d=[r];function h(t,o){return a(),l("div",null,d)}const u=i(n,[["render",h],["__file","dist-id-gen.html.vue"]]);export{u as default};
