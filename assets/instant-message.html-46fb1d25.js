import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as l,e as a}from"./app-ef1338c0.js";const n={},t=a('<h1 id="instant-messaging" tabindex="-1"><a class="header-anchor" href="#instant-messaging" aria-hidden="true">#</a> Instant Messaging</h1><h2 id="pull-and-push" tabindex="-1"><a class="header-anchor" href="#pull-and-push" aria-hidden="true">#</a> Pull and Push</h2><p>到目前为止，我们在网络编程中遇到的全部示例都可以被视为使用“拉取”方法。</p><ul><li>Communication is always initiated by the client</li><li>客户端在需要时从服务器“拉取”数据或服务（例如，当用户启动应用程序或按下按钮时）。</li></ul><p><strong>HTTP</strong> is a <strong>pull-based</strong> protocol</p><ul><li>用户浏览网络并积极决定浏览哪个网站，跟随哪个链接等。</li><li>一种有效且经济的方式（每个用户选择他们需要的）</li><li>然而，如果某些资源被定期请求， pull mode 模型可能会给服务器带来沉重的负载</li></ul><p>有些情况下，服务器希望与客户端（们）建立通信：</p><ul><li>当新电子邮件到达时</li><li>当一个节点通过服务器向用户发送消息时</li><li>当应用程序/数据需要更新时</li></ul><p>在这些情况下，服务器需要将数据或服务“推送”到客户端。这种情况下越来越常见，因为智能手机越来越受欢迎。</p><h2 id="implementing-push" tabindex="-1"><a class="header-anchor" href="#implementing-push" aria-hidden="true">#</a> Implementing Push</h2><p>万维网，特别是HTTP协议，是为“拉”而设计的，要在网上实现“推”需要额外的工程实现。一些在网络上“模拟”推送的方法有</p><ul><li>Polling「轮询」 (periodic pull)</li><li>Comet Model 「彗星模型」</li><li>BOSH</li><li>WebSockets</li></ul><h3 id="polling" tabindex="-1"><a class="header-anchor" href="#polling" aria-hidden="true">#</a> Polling</h3><p>客户端定期轮询服务器以检查是否有新消息或更新可用</p><p><strong>Advantages</strong></p><ul><li>Easy to implement</li><li>No extra development on the server-side</li></ul><p><strong>Disadvantages</strong></p><ul><li>Unnecessary network traffic generated</li><li>Extra workload on the server</li></ul><img src="https://pic.hanjiaming.com.cn/2024/11/09/29adb2c711866.png" alt="1731146674274.png" style="zoom:33%;"><div class="hint-container info"><p class="hint-container-title">Examples</p><ul><li>Post-Office Protocol (POP) for email: 使用POP3协议的电子邮件客户端会定期向邮件服务器发送请求以检查新邮件</li><li>RSS Feed Readers <ul><li>RSS资源由HTTP提供服务，因此都是基于拉取的</li><li>RSS 提要阅读器定期轮询 RSS 服务器并检查提要的新更新</li></ul></li></ul><p>轮询可能会给服务器、客户端和网络带来沉重的负载。</p></div><h3 id="comet-model" tabindex="-1"><a class="header-anchor" href="#comet-model" aria-hidden="true">#</a> Comet Model</h3><p>Comet 模型（也称为反向 Ajax 或长轮询）是一种用于实现服务器到客户端的实时通信的技术。</p><ul><li>“Comet”是一个Web应用程序模型，用于实现允许服务器将数据推送到客户端（浏览器）的Web应用程序。</li><li>它允许服务器在数据可用时主动向客户端发送数据，而不是客户端定期轮询服务器。</li></ul><p>Comet 应用程序的实现分为两大类</p><ul><li>Streaming</li><li>Long-polling</li></ul><h4 id="streaming" tabindex="-1"><a class="header-anchor" href="#streaming" aria-hidden="true">#</a> Streaming</h4><ul><li>A persistent connection is established between the browser and the server</li><li>Data is sent from the server a <strong>chunked block</strong></li><li>事件会逐步发送到浏览器（例如，使用 <code>&lt;script&gt;</code> 标签执行JavaScript命令）</li></ul><img src="https://pic.hanjiaming.com.cn/2024/11/09/147408e758f9a.png" alt="1731158919823.png" style="zoom:33%;"><div class="hint-container warning"><p class="hint-container-title">提示</p><p>虽然 HTTP/2 支持服务器推送（Server Push）和流（Streams），但它仍然是基于 HTTP 的请求/响应模型的。</p><p>服务器推送允许服务器在客户端请求前预先发送数据，但这仍然需要一个初始的客户端请求。</p><ul><li>流允许在单个 TCP 连接上并行处理多个请求和响应，但每个流仍然是基于请求/响应的。另一方面</li><li>WebSocket 是全双工的，一旦连接建立，服务器和客户端都可以随时发送数据。</li></ul></div><h4 id="long-polling" tabindex="-1"><a class="header-anchor" href="#long-polling" aria-hidden="true">#</a> Long-polling</h4><ul><li>请求从客户端发送到服务器</li><li></li></ul>',31),s=[t];function r(o,d){return e(),l("div",null,s)}const c=i(n,[["render",r],["__file","instant-message.html.vue"]]);export{c as default};
