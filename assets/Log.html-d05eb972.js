import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o as s,c as l,a as e,b as r,d as t,e as c}from"./app-44b7245c.js";const d={},o=c(`<h1 id="日志记录" tabindex="-1"><a class="header-anchor" href="#日志记录" aria-hidden="true">#</a> 日志记录</h1><h2 id="class-logger" tabindex="-1"><a class="header-anchor" href="#class-logger" aria-hidden="true">#</a> class Logger</h2><p>多个线程需要同时读写日志，所以需要在写入日志时锁定，防止出现不同步。在多线程中，IO尤其需要防止死锁的出现。</p><p>之前已经说过，log文件的位置以及名称在全局变量中设置。当文件不存在时，将会被自动地创建。</p><p>每一条日志也会输出到终端</p><p>Silver Spork 已经实现了</p><ul><li>文件资源抢占。当一个线程要求logger写入日志的时候，其他进程将会等待，直到资源可用。</li><li>不会出现死锁。无论在读写中是否出现异常，logger最终会被释放以让其他的线程使用。</li><li>内存安全。当产生一行日志后，将立刻追加写入到硬盘中的文件内，不会在内存中堆积。</li><li>追加写入。每次启动程序后，程序将自动写入下划线，以区分不同时间的日志。</li></ul><div class="language-Java line-numbers-mode" data-ext="Java"><pre class="language-Java"><code>synchronized(this){
  try{
    ...
    BufferedWriter bwo = null;
    bwo = new BufferedWriter(new OutputStreamWriter (new FileOutputStream(file, true)));
    bwo.write(text);
    ...
  }finally{
    bwo.close();
    this.notifyAll();
  }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="记录什么" tabindex="-1"><a class="header-anchor" href="#记录什么" aria-hidden="true">#</a> 记录什么</h2><p>Silver Spork 的实现参考了 Nginx Project。日志保留了必要的信息。</p><ul><li>What event <ul><li>new socket come in</li><li>client send a request <ul><li>which type: GET/POST/DELETE etc.</li><li>which url/file</li></ul></li><li>close socket connection</li></ul></li><li>Which socket</li><li>Date (when takes down)</li><li>Which ip address (with port) comes in</li><li>Server resopnse <ul><li>Status: 200/304/400/404</li></ul></li></ul><h2 id="追加记录" tabindex="-1"><a class="header-anchor" href="#追加记录" aria-hidden="true">#</a> 追加记录</h2><p>进程只需要将文本传递给唯一的logger实例。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">&quot;Hello&quot;</span><span class="token punctuation">;</span>
logger<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="reference" tabindex="-1"><a class="header-anchor" href="#reference" aria-hidden="true">#</a> Reference</h2>`,15),u={href:"https://blog.csdn.net/jsjwk/article/details/3942167",target:"_blank",rel:"noopener noreferrer"};function p(h,v){const n=i("ExternalLinkIcon");return s(),l("div",null,[o,e("p",null,[e("a",u,[r("https://blog.csdn.net/jsjwk/article/details/3942167"),t(n)])])])}const g=a(d,[["render",p],["__file","Log.html.vue"]]);export{g as default};
