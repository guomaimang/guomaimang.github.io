import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as i,c as n,e as l}from"./app-5cfac1d9.js";const t={},a=l('<h1 id="redis-sentinel-高可用架构" tabindex="-1"><a class="header-anchor" href="#redis-sentinel-高可用架构" aria-hidden="true">#</a> Redis Sentinel 高可用架构</h1><h2 id="redis-主从复制" tabindex="-1"><a class="header-anchor" href="#redis-主从复制" aria-hidden="true">#</a> Redis 主从复制</h2><h3 id="基础架构" tabindex="-1"><a class="header-anchor" href="#基础架构" aria-hidden="true">#</a> 基础架构</h3><p>要了解 Redis 的高可用架构，首先要了解 Redis 主从复制的过程。</p><img src="https://pic.hanjiaming.com.cn/2024/12/23/2b5920d032139.png" alt="1734968032549.png" style="zoom:25%;"><p>构建高可用架构的基础是构建多个数据相同的节点。我们这里构建了三个 Redis 节点，一个 master 主节点和两个 slave 从属节点，形成一主两从的小集群。这是最常见的 Redis 集群形态。</p><ul><li><strong>Master 主节点</strong>：主要负责数据的写入操作。</li><li><strong>Slave 从属节点</strong>：分担来自应用的读取压力，可以配置读写分离。</li></ul><h3 id="主从复制过程" tabindex="-1"><a class="header-anchor" href="#主从复制过程" aria-hidden="true">#</a> 主从复制过程</h3><p>Redis 主从复制的背后原理如下：</p><figure><img src="https://pic.hanjiaming.com.cn/2024/12/23/720a3f5a15fdd.png" alt="1734968070213.png" tabindex="0" loading="lazy"><figcaption>1734968070213.png</figcaption></figure><ol><li><strong>建立连接</strong>：当 Redis 的 slave 向 master 建立连接时，执行 <code>SLAVE OF</code> 命令。</li><li><strong>生成快照</strong>：作为 Redis 主节点，执行 <code>BGSAVE</code> 命令生成一个 RDB 快照。RDB 是 Redis 中的一种数据备份方式，会将内存中的数据以二进制文件形式在本地保存。</li><li><strong>发送快照</strong>：将生成的 RDB 快照发送到从属服务器上。</li><li><strong>数据还原</strong>：从属服务器接收到 RDB 快照后，读取并还原数据，确保主从数据一致。</li><li><strong>命令转发</strong>：初始化完毕后，主服务器每接收到一个写命令，会将该命令转发给所有从属服务器，从属服务器重新执行命令，保持数据一致。</li></ol><h3 id="主从复制缺点" tabindex="-1"><a class="header-anchor" href="#主从复制缺点" aria-hidden="true">#</a> 主从复制缺点</h3><p><u>如果 Redis master 主节点挂掉，整个小集群就会瘫痪，这是现实应用中不允许的。</u></p><h2 id="redis-sentinel-高可用架构-1" tabindex="-1"><a class="header-anchor" href="#redis-sentinel-高可用架构-1" aria-hidden="true">#</a> Redis Sentinel 高可用架构</h2><h3 id="sentinel-架构概述" tabindex="-1"><a class="header-anchor" href="#sentinel-架构概述" aria-hidden="true">#</a> Sentinel 架构概述</h3><p>Redis 官方提供了一个名为 Sentinel 的高可用集群架构方案。</p><p>Sentinel（哨兵）就像一个哨兵一样（本质是监听程序），为 Redis 集群保驾护航。</p><img src="https://pic.hanjiaming.com.cn/2024/12/23/d00e250454586.png" alt="1734968166702.png" style="zoom:33%;"><p>Sentinel 集群推荐至少六个节点，其中三个 Sentinel 和三个 Redis 主从。</p><ul><li><strong>Sentinel 集群</strong>：由三台 Sentinel 服务器构建，其中一个为 leader 领导者角色。</li><li><strong>健康状态检测</strong>：每个 Sentinel 节点会向 Redis 主从实例发送 PING 命令，确保健康状态，形成网状通信结构。</li></ul><p>每个 Sentinel 以每秒钟一次的频率向它所知的Master，Slavel以及其他Sentinel实例发送一个PING命令。</p><h3 id="故障检测与转移" tabindex="-1"><a class="header-anchor" href="#故障检测与转移" aria-hidden="true">#</a> 故障检测与转移</h3><img src="https://pic.hanjiaming.com.cn/2024/12/23/3db28088e5f51.png" alt="1734968318414.png" style="zoom:33%;"><p>当 Redis master 因某种原因挂掉，Sentinel 会执行以下步骤：</p><ol><li><p><strong>主观下线</strong>：</p><ul><li>Sentinel leader 向 master 发起请求，超时无响应</li><li>如果一个实例 (instance) 距离最后一次有效回复PING命令的时间超过 own-after-milliseconds 选项所指定的值，刚这个实例会被 Sentinel 标记为主观下线。</li><li>主观下线可能是网络通信不畅导致的误判。</li></ul></li><li><p><strong>客观下线</strong>：</p><ul><li>Sentinel leader 通知其他 Sentinel 节点向 master 发起 PING 请求。</li><li>如果足够数量的 Sentinel 节点在指定范围内确认 master 无响应，则标记为客观下线，认为 master 真正宕机。</li></ul></li><li><p><strong>故障转移</strong>：选择新主节点 -&gt; 剔除无效从属节点，选出数据最完整的 slave 节点作为新主节点。</p><ul><li>剔除主观认为已下线、断线或超过一定时长无响应的从属节点。<br><img src="https://pic.hanjiaming.com.cn/2024/12/23/a9f9de0f2bbfc.png" alt="1734968560486.png" style="zoom:33%;"></li><li>剔除与失效主服务器连接断开时长超过 <code>down-after</code> 选项时长十倍的从属节点。</li><li><strong>根据同步数据的偏移量选出数据最完整的 slave 节点。</strong></li><li>如果多个 slave 数据完全同步，则按编号从小到大顺序提升。</li><li><strong>提升新主节点</strong>：Sentinel leader 向新主节点下达 <code>SLAVE OF NO ONE</code> 命令，提升为主节点。</li><li><strong>更新配置</strong>：其他 Sentinel 节点订阅新主节点消息，更新本地配置文件。</li><li><strong>重建连接</strong>：Sentinel leader 向所有从属服务器下达 <code>SLAVE OF</code> 命令，与新主节点建立连接，重新同步数据。</li><li><strong>旧主节点恢复</strong>：原有 master 恢复后，降级为 slave，与新主节点全量同步数据。</li></ul></li></ol><figure><img src="https://pic.hanjiaming.com.cn/2024/12/23/682d7e5ca0863.png" alt="1734968639651.png" tabindex="0" loading="lazy"><figcaption>1734968639651.png</figcaption></figure><h3 id="sentinel-自身高可用" tabindex="-1"><a class="header-anchor" href="#sentinel-自身高可用" aria-hidden="true">#</a> Sentinel 自身高可用</h3><p>Sentinel 本身通过 raft 算法进行选举，确保高可用。</p><img src="https://pic.hanjiaming.com.cn/2024/12/23/b262ab2cd48d8.png" alt="1734968722889.png" style="zoom:33%;"><ul><li><p>选举过程</p><ul><li>集群中超过半数节点投票通过，节点成为主服务器（leader），负责故障转移和命令下达。</li><li>leader 挂掉后，剩余节点重新选举新的 leader。</li></ul></li><li><p>节点发现</p><ul><li><strong>每个 Sentinel 节点接入后，将自己的信息注册到 master 节点上。</strong></li></ul></li><li><p><strong>Sentinel 节点通过 master 获取其他 Sentinel 节点的 IP 地址信息，进行选举和通信。</strong></p></li></ul><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>Redis Sentinel 高可用集群通过故障检测、选举新主节点、更新配置和重建连接等步骤，确保 Redis 集群的高可用性。</p><p>Sentinel 自身通过 raft 算法进行选举，保证服务不中断。</p>',33),s=[a];function r(d,o){return i(),n("div",null,s)}const h=e(t,[["render",r],["__file","redis-sentinel.html.vue"]]);export{h as default};
