import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o as s,c as r,a as e,b as a,d as l,e as o}from"./app-7b037ba0.js";const h={},d=o(`<h1 id="mips汇编语言简易入门3" tabindex="-1"><a class="header-anchor" href="#mips汇编语言简易入门3" aria-hidden="true">#</a> MIPS汇编语言简易入门3</h1><h2 id="remind" tabindex="-1"><a class="header-anchor" href="#remind" aria-hidden="true">#</a> Remind</h2><p>阅读本文之前，你可能需要先学习 MIPS汇编语言简易入门3</p><p><strong>本文探讨内容</strong></p><ul><li>Program flow control</li><li>Subroutine linkage</li></ul><h2 id="program-flow-control" tabindex="-1"><a class="header-anchor" href="#program-flow-control" aria-hidden="true">#</a> Program Flow Control</h2><ul><li>Program is the ordered sequence of instructions</li><li>instructions are executed sequentially</li></ul><p>We want more functionalities: e.g., in high-level-languages, we have if-else, while ( condition), …</p><p>Assembly language build up these functionalities(功能) from basic instructions (the philosophy of RISC「RISC的原理」)</p><h3 id="jump-instruction" tabindex="-1"><a class="header-anchor" href="#jump-instruction" aria-hidden="true">#</a> Jump Instruction</h3><p>Recall: j addr and instruction cycle:<br> fetch — update PC — execute</p><p>How j addr should work?<br> fetch j addr— updata PC — execute j addr (PC = addr)</p><p>But NOT that easy!</p><img src="https://hongshupic.oss-cn-zhangjiakou.aliyuncs.com/2021/02/18/c7305e78034c3.png" alt="image.png" title="image.png" width="240px"><h4 id="branch-delay-slot" tabindex="-1"><a class="header-anchor" href="#branch-delay-slot" aria-hidden="true">#</a> Branch Delay Slot</h4><p>Underlying reason (not required): MIPS is pipelined</p><p>To increase speed, processor will cleverly fetch <strong>multiple instructions</strong> and starts working on them all — a pipeline of instructions.</p><p>The instruction following jump is almost completed when jump is executed</p><p>Instead of wasting efforts, processor will allow to complete that instruction after jump instruction</p><p>The instruction right after jump instruction is called Brach Delay Slot. Not only jump instructions, all the instuctions that include jumping to another address need use Brach Delay Slot.</p><p>Effect: branch delay slot will always be executed</p><p>How to deal with this? — put a no-op instruction right after jump instruction</p><p><strong>Example</strong></p><img src="https://hongshupic.oss-cn-zhangjiakou.aliyuncs.com/2021/02/18/45857a7c3509e.png" alt="image.png" title="image.png"><p><strong>Importantly, PC will be set to addr after the branch delay slot is executed (not after j addr is executed)</strong></p><h3 id="example-of-jump" tabindex="-1"><a class="header-anchor" href="#example-of-jump" aria-hidden="true">#</a> Example of Jump</h3><img src="https://hongshupic.oss-cn-zhangjiakou.aliyuncs.com/2021/02/18/de312597b4e81.png" alt="CleanShot 2021-02-18 at 21.08.02@2x.png" title="CleanShot 2021-02-18 at 21.08.02@2x.png"><p>Hirsun的批注：有一说一，我觉得就是个执行先后的问题。一般执行 Instruction 和PC的改变的执行是同时的。根据上图的解释，如果没有pipeline mechanism（管道机制），PC 就会 按照 jump 0x00400000指令 变成 00400000。但是 因为 pipeline mechanism 的存在，能够先让PC改变，之后再执行这个周期的指令。MIPS在jump 指令使用后 使用 Branch Delay Slot 指令，由于PC收到指令，要变成 00400000。</p><h2 id="other-branch-instructions" tabindex="-1"><a class="header-anchor" href="#other-branch-instructions" aria-hidden="true">#</a> Other Branch Instructions</h2><p>Jump is one of the uncondition branch instructions.</p><p>Jump addr 带走消息</p><ul><li>跳转到 addr指定的指令</li><li>正常做法：使用符号地址；在跳转指令之后立即放置“ no-op”指令</li></ul><p>当然，还有其他的 branch instructions</p><p>主要研究目标：如何使用这些指令以高级语言实现控制结构<br> 例如，跳转可用于实现“无条件循环”</p><h3 id="conditional-branch-instructions" tabindex="-1"><a class="header-anchor" href="#conditional-branch-instructions" aria-hidden="true">#</a> Conditional Branch Instructions</h3><p>条件分支指令仅在满足特定条件时才分支到新地址</p><ul><li>branch on equal: beq u,v, addr # if $u == $v, branches to addr</li><li>branch on not equal: bne u,v, addr # if $u != $v, branches to addr</li><li>branch on less than zero: bltz s, addr # if $s &lt;0, branches to addr; note: $s in 2’s complement form</li><li>branch on greater than or equal to zero: bge z s, addr # if $s&gt;=0, branches to zero. note: $s in 2’s complement form</li></ul><p>以上 branch instructions 之后 都要添加 Branch Delay Slot 指令。</p><h3 id="example-1" tabindex="-1"><a class="header-anchor" href="#example-1" aria-hidden="true">#</a> Example 1</h3><p>Essentially, the conditional branch instructions implement the “if … then do sth” control structure</p><p>branch on equal: beq u,v, addr # if $u == $v, branches to addr</p><p>程序流程图</p><img src="https://hongshupic.oss-cn-zhangjiakou.aliyuncs.com/2021/02/21/4e28793169c1d.png" alt="CleanShot 2021-02-21 at 19.13.23@2x.png" title="CleanShot 2021-02-21 at 19.13.23@2x.png"><h3 id="example-2" tabindex="-1"><a class="header-anchor" href="#example-2" aria-hidden="true">#</a> Example 2</h3><p>Two-way decision control structure: if true, do A; else do B</p><p>combine of conditional branch and jump</p><img src="https://hongshupic.oss-cn-zhangjiakou.aliyuncs.com/2021/02/21/5ce351b5c2f6d.png" alt="CleanShot 2021-02-21 at 19.17.22@2x.png" title="CleanShot 2021-02-21 at 19.17.22@2x.png"><p><strong>A good practice: draw the flow chart of the program first</strong></p><h3 id="example-3" tabindex="-1"><a class="header-anchor" href="#example-3" aria-hidden="true">#</a> Example 3</h3><p>Program task: calculate the absolute value of A stored at a given address</p><ul><li>idea: if A &lt; 0: store -A; else do nothing</li><li>we can use one conditional branch instruction</li></ul><img src="https://hongshupic.oss-cn-zhangjiakou.aliyuncs.com/2021/02/21/34703d7692684.png" alt="CleanShot 2021-02-21 at 19.29.38@2x.png" title="CleanShot 2021-02-21 at 19.29.38@2x.png"><p>the blank should fill with 0.</p><p>Question1: Determine if A is negative or not</p><ul><li>check the “sign” bit (at position 31) of A (assume 2’s complement form)</li><li>shift right logical: srl $t0, $t1, const; shift the bits in $t1 to the right for const positions, and fill the left positions with 0; store the result in $t0</li><li>note, we stored the value of A in $8; question: what’s the value of $9 after srl $9, $8, 31</li></ul><p>Question2: Determine if A is negative or not</p><ul><li>the value of $9: first 31 bits are all 0, the last bit is the sign bit of A</li><li>as a result, if $9 == 0, A is positive (or 0)</li></ul><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>    .text
    .globl main

main:
# Load A
    lui      $10, 0x1000 # initialize the base register
    lw      $8, 0 ($10)  # load A to register $8
# Is A negative?
    srl    $9, $8, 31  # shift the sign bit to position 0
    beq   $0, $9, done # check if $9 == 0
    sll     $0, $0, 0  # branch delay slot
# Store -A
    subu  $8, $0, $8   #calculate -A
    sw      $8, 0($10)  # store -A back to the address
done: 
         .data
A:     .word -1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="count-loop" tabindex="-1"><a class="header-anchor" href="#count-loop" aria-hidden="true">#</a> Count Loop</h2><p>A common type of program loop — execute for some fixed times, controlled by an integer (counter)</p><p>Three critical(关键的) parts</p><ul><li>initialize the counter</li><li>test the counter value and end the loop on the correct value</li><li>increment the counter</li></ul><p>A top-driven loop in assembly language</p><ul><li>check the condition on the top</li><li>use a combination of conditional branch, jump, and conditional set instructions</li></ul><img src="https://hongshupic.oss-cn-zhangjiakou.aliyuncs.com/2021/02/21/b842a22b543e0.png" alt="image.png" title="image.png" width="240px"><h3 id="conditional-set-instructions" tabindex="-1"><a class="header-anchor" href="#conditional-set-instructions" aria-hidden="true">#</a> Conditional Set Instructions</h3><p>Used to implement relational operations</p><ul><li>idea: set a register to 1 or 0 to show the relation between two values (often used as a flag)</li><li>note: it will not change the program flow itself — rather, it can be used as some condition to trigger the branch instructions</li></ul><h4 id="set-on-less-than-slt" tabindex="-1"><a class="header-anchor" href="#set-on-less-than-slt" aria-hidden="true">#</a> Set on Less Than slt</h4><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>slt d, s, t # $s and $t contains signed integers in 2’s complement  
# set $d = 1 if $s &lt; $t; else, set $d = 0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="other-conditional-set-instructions" tabindex="-1"><a class="header-anchor" href="#other-conditional-set-instructions" aria-hidden="true">#</a> Other conditional set instructions</h4><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>sltu d, s, t # used with unsigned integers
slti d, s, imm # Set on Less Than Immediate 
               # if $s &lt; imm, set $d =1; 
               # else, set $d = 0
sltiu d, s, imm # used with unsigned integers
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="example" tabindex="-1"><a class="header-anchor" href="#example" aria-hidden="true">#</a> Example</h4><img src="https://hongshupic.oss-cn-zhangjiakou.aliyuncs.com/2021/02/21/3a5a1e262454c.png" alt="CleanShot 2021-02-21 at 21.57.51@2x.png" title="CleanShot 2021-02-21 at 21.57.51@2x.png"><h3 id="example-4" tabindex="-1"><a class="header-anchor" href="#example-4" aria-hidden="true">#</a> Example</h3><img src="https://hongshupic.oss-cn-zhangjiakou.aliyuncs.com/2021/02/21/8fadb34273d15.png" alt="CleanShot 2021-02-21 at 22.03.02@2x.png" title="CleanShot 2021-02-21 at 22.03.02@2x.png"><h2 id="subroutine-linkage" tabindex="-1"><a class="header-anchor" href="#subroutine-linkage" aria-hidden="true">#</a> Subroutine Linkage</h2><p>子程序（Subroutine）是什么？</p><ul><li>子例程是代码的逻辑划分，可以被视为独立操作</li><li>所有高级语言都有子例程的概念，也称为过程，函数，方法</li><li>子程序可以根据需要在程序中使用</li></ul><h3 id="try-with-jump-instruction" tabindex="-1"><a class="header-anchor" href="#try-with-jump-instruction" aria-hidden="true">#</a> Try with Jump Instruction</h3><p>假设我们使用sub来标记子例程的起始地址</p><p>想法：调用子程序=跳转到子程序</p><img src="https://hongshupic.oss-cn-zhangjiakou.aliyuncs.com/2021/02/21/744d1cbc702df.png" alt="image.png" title="image.png" width="240px"><p>在主程序中，我们跳到子程序（即调用子程序）</p><p>完成子程序后，我们需要返回主程序</p><p>How？jump 到ret（在j子之后，将指令重新标记）</p><p><strong>如果我们想在主程序中多次调用子程序怎么办？</strong></p><img src="https://hongshupic.oss-cn-zhangjiakou.aliyuncs.com/2021/02/21/1386938b9a278.png" alt="CleanShot 2021-02-21 at 22.15.49@2x.png" title="CleanShot 2021-02-21 at 22.15.49@2x.png"><p>问题是很多地方调用了sub，我们不知道执行完sub后该回到哪个地方。</p><p>所以，这个时候我们就要用到 $ra Register</p><h3 id="ra-register" tabindex="-1"><a class="header-anchor" href="#ra-register" aria-hidden="true">#</a> $ra Register</h3><ul><li>$ra ($31) is the register used for linkage, it holds the return address for a subroutine</li><li>idea: when we call a subroutine, we store the return address in $ra; when the subroutine is finished, the program returns to that address</li><li>implementation: a pair of instructions jal and jr</li></ul><h4 id="jal-and-jr-instruction" tabindex="-1"><a class="header-anchor" href="#jal-and-jr-instruction" aria-hidden="true">#</a> jal and jr Instruction</h4><h5 id="jal-sub" tabindex="-1"><a class="header-anchor" href="#jal-sub" aria-hidden="true">#</a> jal sub</h5><p>(1) set $ra to PC + 4</p><p>the result is that $ra stores the address of the (n+2)th instruction (suppose jar is the nth instruction)</p><p>in memory: jal| branch delay slot | instruction that will return to</p><p>(2) set PC to sub</p><h5 id="jr-ra" tabindex="-1"><a class="header-anchor" href="#jr-ra" aria-hidden="true">#</a> jr $ra</h5><p>set PC to $ra</p><h4 id="jal-example" tabindex="-1"><a class="header-anchor" href="#jal-example" aria-hidden="true">#</a> Jal Example</h4><img src="https://hongshupic.oss-cn-zhangjiakou.aliyuncs.com/2021/02/21/1577980e7d9b2.png" alt="CleanShot 2021-02-21 at 22.50.45@2x.png" title="CleanShot 2021-02-21 at 22.50.45@2x.png"><h3 id="calling-convention" tabindex="-1"><a class="header-anchor" href="#calling-convention" aria-hidden="true">#</a> Calling Convention</h3><p>Calling convention is the agreement about how subroutines are called and how control is returned</p><ul><li>an agreement at the software level</li><li>different languages and different operating systems for the same processor usually have different calling conventions</li></ul><img src="https://hongshupic.oss-cn-zhangjiakou.aliyuncs.com/2021/02/21/9eb3aee3c3557.png" alt="image.png" title="image.png" width="240px"><h4 id="use-of-registers" tabindex="-1"><a class="header-anchor" href="#use-of-registers" aria-hidden="true">#</a> Use of Registers</h4><p>Caller (e.g., main routine) and Callee (subroutine) both use registers to store data「调用者（例如主例程）和被调用者（子例程）都使用寄存器来存储数据」</p><p>conflict may happen — caller stored some data in a register and the callee may also use the register and change the data</p><p>it’s silly to go back to the caller to check which registers are used when writing subroutines — we need agreement among programmers</p><h4 id="different-roles-of-registers" tabindex="-1"><a class="header-anchor" href="#different-roles-of-registers" aria-hidden="true">#</a> Different roles of registers</h4><ul><li>$t0 - t9: subroutines can use without caution</li><li>$s0 - $s7: saved registers; if need to use it, save the value first and restore the value after use</li><li>$a0 - $a3: contain arguments for the subroutine</li><li>$v0 - $v1: contain values returned from the subroutine</li></ul><p>翻译</p><p>「$ t0-t9：子程序可以不加警告地使用<br> $ s0-$ s7：保存的寄存器；如果需要使用它，请先保存该值，然后再使用后恢复该值<br> $ a0-$ a3：包含子例程的参数<br> $ v0-$ v1：包含从子例程返回的值」</p><p>Example: is the following code a good convention（惯例）?</p><img src="https://hongshupic.oss-cn-zhangjiakou.aliyuncs.com/2021/02/21/f5423e234325c.png" alt="CleanShot 2021-02-21 at 23.10.25@2x.png" title="CleanShot 2021-02-21 at 23.10.25@2x.png"><h4 id="a-simple-mips-calling-convention" tabindex="-1"><a class="header-anchor" href="#a-simple-mips-calling-convention" aria-hidden="true">#</a> A Simple MIPS Calling Convention</h4><p>Try to obey the following simple convention</p><ul><li>use jal and jr with $ra to call subroutines</li><li>do not call another subroutine within a subroutine</li><li>obey the conventional use of registers</li></ul><p>Note: there are more complex calling conventions</p><h2 id="推荐" tabindex="-1"><a class="header-anchor" href="#推荐" aria-hidden="true">#</a> 推荐</h2>`,121),c={href:"https://chortle.ccsu.edu/AssemblyTutorial/index.html#part7",target:"_blank",rel:"noopener noreferrer"},u=e("h2",{id:"引用资料",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#引用资料","aria-hidden":"true"},"#"),a(" 引用资料")],-1),p=e("ul",null,[e("li",null,"COMP2421@Polyu's learning lecture")],-1);function m(g,b){const i=t("ExternalLinkIcon");return s(),r("div",null,[d,e("p",null,[a("a good online source: "),e("a",c,[a("https://chortle.ccsu.edu/AssemblyTutorial/index.html#part7"),l(i)])]),u,p])}const x=n(h,[["render",m],["__file","MIPS汇编语言简易入门3.html.vue"]]);export{x as default};
