import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as i,c as t,e as a}from"./app-454f912f.js";const n={},o=a('<h1 id="sarm-sequential-analysis" tabindex="-1"><a class="header-anchor" href="#sarm-sequential-analysis" aria-hidden="true">#</a> SARM: Sequential Analysis</h1><p>Mining <u>Sequential Association Rules</u> 是数据挖掘领域中的一种技术，用于从大量的序列数据中挖掘出有意义的模式和关系。这种技术在许多应用中都很有用，比如市场篮子分析、客户购买行为分析、网络日志分析、生物信息学中的基因和蛋白质序列分析等。</p><p>与传统的关联规则挖掘不同，<strong><u>序列</u>关联规则挖掘关注的是在序列中的项目之间的时间或顺序关系</strong>。也就是说，<strong>它不仅仅是寻找经常一起出现的项目，而是寻找按特定顺序出现的项目。</strong></p><p>简单来说，考虑这样一个例子：假设有一个零售商想要分析客户的购买记录，**以找出随着时间推移客户可能购买的产品序列。**他们可以使用序列关联规则挖掘来找到像“<strong>如果一个客户先买了 A，然后买了 B，那么他们很可能最后会买 C</strong>”这样的模式。</p><p>为了挖掘这些规则，研究者提出了许多算法，如Apriori-based、PrefixSpan、GSP（Generalized Sequential Patterns）等。这些算法首先识别频繁出现的序列模式，然后基于这些模式生成关联规则。</p><div class="hint-container note"><p class="hint-container-title">Example</p><ul><li>客户通常会租借《星球大战》、《帝国反击战》和《绝地归来》</li><li>HSI went “Up”, then “Level”, then “Up”, and then “Down”</li><li>客户阅读 &quot;财经新闻&quot;，然后是 &quot;头条新闻&quot;，最后是 &quot;娱乐新闻&quot;。</li></ul></div><h2 id="frequent-sequences" tabindex="-1"><a class="header-anchor" href="#frequent-sequences" aria-hidden="true">#</a> Frequent Sequences</h2><p>什么是顺序模式「sequential pattern」挖掘？</p><p>Based on <strong>computing</strong> the <u>frequent sequences</u> (vs computing the frequent itemsets in non-sequential ARM)</p><p>Sequence consists of <u>a list of itemset</u> in temporal order 「按时间顺序」and is denoted as <code>&lt;s1, s2, ..., sn&gt;</code>, where <code>si</code> is the i-th <u>itemset</u> (not item!) in the sequence.</p><p><u>Objectives of SPM</u>: Given a database D of customer transactions, the problem of mining sequential patterns is to <strong>find all sequential patterns with user-specified minimum support</strong></p><p><u>Customer Sequence</u>: 客户的所有交易是一个按交易时间递增排序的序列。</p><figure><img src="https://pic.hanjiaming.com.cn/2023/10/06/aaba98420b4b6.png" alt="1696586332319.png" tabindex="0" loading="lazy"><figcaption>1696586332319.png</figcaption></figure><p>表格表示了如下的客户购买序列：</p><ol><li>客户1: 先买了商品30，然后在之后的事务中买了商品90。</li><li>客户2: 先买了商品10和20，然后买了商品30，接着在之后的事务中买了商品40、60和70。</li><li>客户3: 在一个事务中买了商品30、50和70。</li><li>客户4: 先买了商品30，然后在之后的事务中买了商品40和70，接着在另一个事务中买了商品90。</li><li>客户5: 只在一个事务中买了商品90。</li></ol><p>给定的最小支持度是25%，这意味着为了被视为频繁的序列，一个序列必须至少被5名客户中的25%，即至少2名客户所支持。</p><p>从上面的数据中，我们可以得到以下频繁序列：</p><ul><li>&lt;(30),(90)&gt;: 客户1和客户4都有这个序列，因此支持度是2/5 = 40% &gt; 25%。 <ul><li>&lt; (30),(90) &gt; 序列的意思是有至少25%的客户先购买了商品30，然后在之后的事务中购买了商品90。</li></ul></li><li>&lt;(30),(40 70)&gt;: 客户2和客户4都有这个序列，因此支持度是2/5 = 40% &gt; 25%。</li></ul><p>所以，这两个序列都是频繁的。</p><h2 id="mining-steps" tabindex="-1"><a class="header-anchor" href="#mining-steps" aria-hidden="true">#</a> Mining Steps</h2><p>从事务数据库中提取频繁序列：</p><ol><li><strong>排序阶段</strong>「Sort Phase」: 将数据库按照客户ID进行排序，若有相同的客户ID，<strong>则按照交易时间排序</strong>。</li><li><strong>频繁阶段</strong>「Frequent Itemset Phase」: 使用 Apriori 算法找到所有频繁的商品集合。</li><li><strong>转换阶段</strong>「Transformation Phase」: 将每个客户的交易序列转换为频繁商品集合的表示。</li><li><strong>序列阶段</strong>「Sequence Phase」: 使用上面的频繁商品集合找到所需的序列。具体的算法可能是AprioriAll、AprioriSome或DynamicSome（具体请参阅原始论文）。</li><li><strong>最大化阶段</strong>「Maximal Phase」 (可选): 在频繁序列集合中找到最大的序列。</li></ol><h3 id="transformation-phase" tabindex="-1"><a class="header-anchor" href="#transformation-phase" aria-hidden="true">#</a> Transformation Phase</h3><figure><img src="https://pic.hanjiaming.com.cn/2023/10/06/9870c56e9e836.png" alt="1696588813114.png" tabindex="0" loading="lazy"><figcaption>1696588813114.png</figcaption></figure><div class="hint-container warning"><p class="hint-container-title">注意</p><p>需要注意的是 D&#39; 表是 <u>基于客户</u>的表，而不是基于事务。这是因为在序列模式挖掘中，我们更关心的是多少个<strong>不同的客户</strong>遵循某个特定的购买模式，而不是这个模式在多少个<strong>不同的事务</strong>中出现。</p></div><details class="hint-container details"><summary>如何从表1获得表2</summary><p><strong>计算每个商品的支持度</strong>:</p><ul><li>商品30: 有3位客户购买了商品30（客户1、客户2和客户3），所以它的支持度是3/5 = 60%。</li><li>商品90: 有3位客户购买了商品90（客户1、客户4和客户5），所以它的支持度是3/5 = 60%。</li><li>商品10: 只有客户2购买了商品10，所以支持度是1/5 = 20%。</li><li>商品20: 同样，只有客户2购买了商品20，所以支持度是1/5 = 20%。</li><li>商品40: 有2位客户购买了商品40（客户2和客户4），所以它的支持度是2/5 = 40%。</li><li>商品50: 只有客户3购买了商品50，所以支持度是1/5 = 20%。</li><li>商品60: 只有客户2购买了商品60，所以支持度是1/5 = 20%。</li><li>商品70: 有3位客户购买了商品70（客户2、客户3和客户4），所以它的支持度是3/5 = 60%。</li></ul><p><strong>过滤小于最小支持度的商品</strong>: 由于 Minsup=25%，<strong>我们只保留那些支持度大于或等于25%的商品。因此，我们保留了商品30、90、40和70。</strong></p><p><strong>映射频繁商品集</strong>:</p><table><thead><tr><th><strong>Mapped to</strong></th><th><strong>Freq. Itemsets</strong> <strong>†</strong></th></tr></thead><tbody><tr><td>1</td><td>&lt;(30)&gt;</td></tr><tr><td>2</td><td>&lt;(40)&gt;</td></tr><tr><td>3</td><td>&lt;(70)&gt;</td></tr><tr><td>4</td><td>&lt;(40),(90)&gt;</td></tr><tr><td>5</td><td>&lt;(90)&gt;</td></tr></tbody></table></details><h3 id="aprioriall-algorithm" tabindex="-1"><a class="header-anchor" href="#aprioriall-algorithm" aria-hidden="true">#</a> AprioriAll Algorithm</h3><p>AprioriAll 算法的目标是找到频繁序列，即在数据中经常出现的顺序模式。</p><figure><img src="https://pic.hanjiaming.com.cn/2023/10/06/81ca6a92a9d87.png" alt="1696597354900.png" tabindex="0" loading="lazy"><figcaption>1696597354900.png</figcaption></figure><p>AprioriAll算法的基本原理是：任何非频繁的子序列都不会是频繁的序列。因此，该算法从长度为1的序列开始，逐渐增加序列的长度，只考虑那些子序列已经被证明是频繁的序列。</p><figure><img src="https://pic.hanjiaming.com.cn/2023/10/06/e2f0acda82557.png" alt="1696595525632.png" tabindex="0" loading="lazy"><figcaption>1696595525632.png</figcaption></figure><h3 id="generate-candidate-sequences" tabindex="-1"><a class="header-anchor" href="#generate-candidate-sequences" aria-hidden="true">#</a> Generate Candidate Sequences</h3><img src="https://pic.hanjiaming.com.cn/2023/10/06/3170487357d37.png" alt="1696597758905.png" style="zoom:33%;"><p>Example</p><ul><li>L3 = <code>{abc, abd, acd, ace, bcd}</code></li><li>Self-joining: <code>L3*L3</code><ul><li><code>abcd</code> and <code>abdc</code> from<code>abc</code> and <code>abd</code></li><li><code>acde</code> and <code>aced</code> from <code>acd</code> and <code>ace</code></li></ul></li><li>Pruning: <ul><li><code>abdc</code> is removed because <code>adc/bdc</code> is not in L3</li><li><code>acde</code> is removed because <code>ade/cde</code> is not in L3</li><li><code>aced</code> is removed because <code>aed/ced</code> is not in L3</li></ul></li><li>C4= <code>{abcd}</code></li></ul><h3 id="maximal-phase" tabindex="-1"><a class="header-anchor" href="#maximal-phase" aria-hidden="true">#</a> Maximal Phase</h3><p>Essential Definitions for Phase 5: Maximal Phase</p><p>如果一个序列是频繁的，并且它没有任何频繁的超集，则该序列称为最大频繁序列。</p><p>Consider the examples:</p><ul><li><code>&lt;(3),(45),(8)&gt;</code> is contained in <code>&lt;(7),(38),(9),(456),(8)&gt;</code>? YES</li><li><code>&lt;(3),(5)&gt;</code>is contained in<code>&lt;(35)&gt;</code>? NO</li></ul><h2 id="forming-rules" tabindex="-1"><a class="header-anchor" href="#forming-rules" aria-hidden="true">#</a> Forming Rules</h2><p>Again, the user specified <strong>confidence</strong> is used by the rule generation step to qualify the strength of the sequential association rules.</p><p>规则生成步骤相当简单，比如</p><ul><li>&lt;1234&gt; will form1→234,12→34, 123→4</li><li>但是，13→24，124→3， 等无法形成，因为时间顺序被扭曲了！！</li></ul>',44),s=[o];function r(l,d){return i(),t("div",null,s)}const g=e(n,[["render",r],["__file","arm2.html.vue"]]);export{g as default};
