import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as a,e as n}from"./app-0e313ca3.js";const d={},s=n(`<h1 id="java-文本-io-和-流" tabindex="-1"><a class="header-anchor" href="#java-文本-io-和-流" aria-hidden="true">#</a> Java 文本 IO 和 流</h1><h2 id="从控制台读取输入" tabindex="-1"><a class="header-anchor" href="#从控制台读取输入" aria-hidden="true">#</a> 从控制台读取输入</h2><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Scanner</span></span><span class="token punctuation">;</span> <span class="token comment">// Scanner is in the java.util package</span>

<span class="token comment">// Create a Scanner object</span>
<span class="token class-name">Scanner</span> input <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Prompt the user to enter a radius</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;Enter a number for radius: &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">double</span> radius <span class="token operator">=</span> input<span class="token punctuation">.</span><span class="token function">nextDouble</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>input.next()</code> 返回String，以任意空白字符为结束符 <code>&#39;&#39;, &#39;\\t&#39;, &#39;\\n&#39;, &#39;\\f&#39; </code> 等</li><li><code>input.nextLine() </code>返回一整行String，以回车为结束符</li><li>还有<code>nextByte()</code>，<code>nextInt()</code>等</li></ul><div class="hint-container tip"><p class="hint-container-title">Java 命令行传参</p><p>Java 中，命令行参数传参，直接就是参数数组，不含任何名称路径等信息。</p></div><h2 id="java-流总结" tabindex="-1"><a class="header-anchor" href="#java-流总结" aria-hidden="true">#</a> Java 流总结</h2><p>Java I/O库中有许多不同的流类，它们都有各自的用途。以下是一些常见的流类及其用途：</p><table><thead><tr><th>类名</th><th>用途</th></tr></thead><tbody><tr><td><code>InputStream</code></td><td>这是所有字节输入流类的<strong>超类</strong>，它定义了读取字节的基本接口。</td></tr><tr><td><code>OutputStream</code></td><td>这是所有字节输出流类的<strong>超类</strong>，它定义了写入字节的基本接口。</td></tr><tr><td><code>ByteArrayInputStream</code></td><td><strong>这个流类将字节数组作为源，用于从字节数组读取数据。</strong></td></tr><tr><td><code>ByteArrayOutputStream</code></td><td>这个流类将内存作为目标，用于将数据写入字节数组。</td></tr><tr><td><code>FileInputStream</code></td><td>这个流类将文件作为源，用于从文件读取数据。</td></tr><tr><td><code>FileOutputStream</code></td><td>这个流类将文件作为目标，用于将数据写入文件。</td></tr><tr><td><code>BufferedInputStream</code></td><td><strong>这个流类为另一个输入流添加了缓冲功能，使得读取操作更高效。</strong></td></tr><tr><td><code>BufferedOutputStream</code></td><td><strong>这个流类为另一个输出流添加了缓冲功能，使得写入操作更高效。</strong></td></tr><tr><td><code>DataInputStream</code></td><td>这个流类允许你以平台无关的方式从输入流中读取基本数据类型。</td></tr><tr><td><code>DataOutputStream</code></td><td>这个流类允许你以平台无关的方式将基本数据类型写入输出流。</td></tr><tr><td><code>ObjectInputStream</code></td><td>这个流类允许你从输入流中读取对象。</td></tr><tr><td><code>ObjectOutputStream</code></td><td>这个流类允许你将对象写入输出流。</td></tr><tr><td><code>PrintStream</code></td><td>这个流类包含了 <code>print()</code> 和 <code>println()</code> 方法，可以很方便地写入字符串表示的各种数据值。</td></tr><tr><td><code>PipedInputStream</code>/<code>PipedOutputStream</code></td><td>这些流类允许在不同的线程之间进行管道通信。</td></tr><tr><td><code>SequenceInputStream</code></td><td>这个流类可以将多个输入流合并为一个，按顺序读取它们。</td></tr></tbody></table><p>Java I/O库的一个强大之处在于它的流类可以组合起来使用，以提供更复杂的功能。这是通过使用装饰器模式实现的，这意味着你可以用一个流（例如，<code>BufferedOutputStream</code>）来&quot;装饰&quot;另一个流（例如，<code>FileOutputStream</code>），从而在基础流上添加更多的功能（在这个例子中，是缓冲功能）。</p><p>以下是一些常见的流组合及其用途：以上只是一些例子，实际上你可以按照需要将各种流组合在一起。例如，你可以将 <code>BufferedOutputStream</code> 和 <code>DataOutputStream</code> 组合在一起，以高效地将基本数据类型写入文件。你只需要确保每个流都正确地使用了装饰器模式，即每个流都被封装在另一个流中，以添加更多的功能。</p><table><thead><tr><th>组合</th><th>用途</th></tr></thead><tbody><tr><td><code>BufferedInputStream(FileInputStream)</code></td><td>从文件中高效地读取数据。<code>BufferedInputStream</code> 为文件输入流添加了缓冲功能，这意味着它可以一次从文件中读取多个字节，而不是一个接一个地读取，从而提高了读取效率。</td></tr><tr><td><code>BufferedOutputStream(FileOutputStream)</code></td><td>高效地将数据写入文件。<code>BufferedOutputStream</code> 为文件输出流添加了缓冲功能，这意味着它可以一次将多个字节写入文件，而不是一个接一个地写入，从而提高了写入效率。</td></tr><tr><td><code>DataOutputStream(FileOutputStream)</code></td><td>将基本数据类型以平台无关的方式写入文件。<code>DataOutputStream</code> 为文件输出流添加了写入基本数据类型的功能，这意味着你可以将整数、浮点数等以特定的格式写入文件，而不只是原始的字节数据。</td></tr><tr><td><code>DataInputStream(FileInputStream)</code></td><td>以平台无关的方式从文件中读取基本数据类型。<code>DataInputStream</code> 为文件输入流添加了读取基本数据类型的功能，这意味着你可以从文件中读取整数、浮点数等，而不只是原始的字节数据。</td></tr><tr><td><code>PrintStream(FileOutputStream)</code></td><td>将格式化的数据写入文件。<code>PrintStream</code> 为文件输出流添加了写入格式化数据的功能，这意味着你可以使用 <code>print()</code> 和 <code>println()</code> 方法将数据写入文件，这些数据可以是字符串、数字或其他对象的字符串表示形式。</td></tr><tr><td><code>ObjectOutputStream(FileOutputStream)</code></td><td>将对象序列化并写入文件。<code>ObjectOutputStream</code> 为文件输出流添加了写入对象的功能，这意味着你可以将任何实现了 <code>Serializable</code> 接口的对象写入文件。</td></tr><tr><td><code>ObjectInputStream(FileInputStream)</code></td><td>从文件中反序列化并读取对象。<code>ObjectInputStream</code> 为文件输入流添加了读取对象的功能，这意味着你可以从文件中读取任何实现了 <code>Serializable</code> 接口的对象。</td></tr></tbody></table><div class="hint-container info"><p class="hint-container-title">\`BufferedOutputStream(FileOutputStream)\` 的实现</p><p>缓存的实现，类似于是个接水滴的水桶，水满了再到倒到蓄水池中，而不是接一滴倒一次接一滴倒一次。这就是说，每次读取一整块文件到内存中，每次从内存中访问，避免了频繁访问硬盘IO。</p><p><code>BufferedInputStream(FileInputStream)</code> 亦如此。</p></div>`,12),o=[s];function c(r,p){return e(),a("div",null,o)}const l=t(d,[["render",c],["__file","text-io.html.vue"]]);export{l as default};
